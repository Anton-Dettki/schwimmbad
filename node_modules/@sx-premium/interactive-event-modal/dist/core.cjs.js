'use strict';

var signals = require('@preact/signals');
var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var preact = require('preact');
var compat = require('preact/compat');

const rruleFields = () => {
    return {
        rruleFrequency: {},
        rruleUntil: {},
        rruleCustomFrequency: {},
        rruleInterval: {},
        rruleCount: {},
        rruleByDay: {},
    };
};

const createInputField = (field) => {
    const reactiveInputField = signals.signal({
        ...field,
        rerender: () => (reactiveInputField.value = { ...reactiveInputField.value }),
    });
    return reactiveInputField;
};

/**
 * Origin of SVG: https://www.svgrepo.com/svg/506771/time
 * License: PD License
 * Author Salah Elimam
 * Author website: https://www.figma.com/@salahelimam
 * */
function TimeIcon({ strokeColor }) {
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("svg", { className: "sx__event-icon", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { id: "SVGRepo_iconCarrier", children: [jsxRuntime.jsx("path", { d: "M12 8V12L15 15", stroke: strokeColor, "stroke-width": "2", "stroke-linecap": "round" }), jsxRuntime.jsx("circle", { cx: "12", cy: "12", r: "9", stroke: strokeColor, "stroke-width": "2" })] })] }) }));
}

/**
 * Origin of SVG: https://www.svgrepo.com/svg/506772/user
 * License: PD License
 * Author Salah Elimam
 * Author website: https://www.figma.com/@salahelimam
 * */
function UserIcon({ strokeColor }) {
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("svg", { className: "sx__event-icon", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { id: "SVGRepo_iconCarrier", children: [jsxRuntime.jsx("path", { d: "M15 7C15 8.65685 13.6569 10 12 10C10.3431 10 9 8.65685 9 7C9 5.34315 10.3431 4 12 4C13.6569 4 15 5.34315 15 7Z", stroke: strokeColor, "stroke-width": "2" }), jsxRuntime.jsx("path", { d: "M5 19.5C5 15.9101 7.91015 13 11.5 13H12.5C16.0899 13 19 15.9101 19 19.5V20C19 20.5523 18.5523 21 18 21H6C5.44772 21 5 20.5523 5 20V19.5Z", stroke: strokeColor, "stroke-width": "2" })] })] }) }));
}

/**
 * Origin of SVG: https://www.svgrepo.com/svg/506838/list
 * License: PD License
 * Author: Salah Elimam
 * Author website: https://www.figma.com/@salahelimam
 * */
function DescriptionIcon({ strokeColor }) {
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("svg", { className: "sx__event-icon", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { id: "SVGRepo_iconCarrier", children: [jsxRuntime.jsx("rect", { x: "4", y: "4", width: "16", height: "16", rx: "3", stroke: strokeColor, "stroke-width": "2" }), jsxRuntime.jsx("path", { d: "M16 10L8 10", stroke: strokeColor, "stroke-width": "2", "stroke-linecap": "round" }), jsxRuntime.jsx("path", { d: "M16 14L8 14", stroke: strokeColor, "stroke-width": "2", "stroke-linecap": "round" })] })] }) }));
}

/**
 * Origin of SVG: https://www.svgrepo.com/svg/489502/location-pin
 * License: PD License
 * Author: Dariush Habibpour
 * Author website: https://redl.ink/dariush/links?ref=svgrepo.com
 * */
function LocationPinIcon({ strokeColor }) {
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("svg", { className: "sx__event-icon", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { id: "SVGRepo_iconCarrier", children: [jsxRuntime.jsxs("g", { "clip-path": "url(#clip0_429_11046)", children: [jsxRuntime.jsx("rect", { x: "12", y: "11", width: "0.01", height: "0.01", stroke: strokeColor, "stroke-width": "2", "stroke-linejoin": "round" }), jsxRuntime.jsx("path", { d: "M12 22L17.5 16.5C20.5376 13.4624 20.5376 8.53757 17.5 5.5C14.4624 2.46244 9.53757 2.46244 6.5 5.5C3.46244 8.53757 3.46244 13.4624 6.5 16.5L12 22Z", stroke: strokeColor, "stroke-width": "2", "stroke-linejoin": "round" })] }), jsxRuntime.jsx("defs", { children: jsxRuntime.jsx("clipPath", { id: "clip0_429_11046", children: jsxRuntime.jsx("rect", { width: "24", height: "24", fill: "white" }) }) })] })] }) }));
}

const definePlugin = (name, definition) => {
    definition.name = name;
    return definition;
};

// regex for strings between 00:00 and 23:59
const timeStringRegex = /^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/;
const dateTimeStringRegex = /^(\d{4})-(\d{2})-(\d{2}) (0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/;
const dateStringRegex = /^(\d{4})-(\d{2})-(\d{2})$/;

const DateFormats$1 = {
    DATE_STRING: /^\d{4}-\d{2}-\d{2}$/,
    DATE_TIME_STRING: /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/,
};

let InvalidDateTimeError$1 = class InvalidDateTimeError extends Error {
    constructor(dateTimeSpecification) {
        super(`Invalid date time specification: ${dateTimeSpecification}`);
    }
};

const toJSDate$1 = (dateTimeSpecification) => {
    if (!DateFormats$1.DATE_TIME_STRING.test(dateTimeSpecification) &&
        !DateFormats$1.DATE_STRING.test(dateTimeSpecification))
        throw new InvalidDateTimeError$1(dateTimeSpecification);
    return new Date(Number(dateTimeSpecification.slice(0, 4)), Number(dateTimeSpecification.slice(5, 7)) - 1, Number(dateTimeSpecification.slice(8, 10)), Number(dateTimeSpecification.slice(11, 13)), // for date strings this will be 0
    Number(dateTimeSpecification.slice(14, 16)) // for date strings this will be 0
    );
};
const toIntegers$1 = (dateTimeSpecification) => {
    const hours = dateTimeSpecification.slice(11, 13), minutes = dateTimeSpecification.slice(14, 16);
    return {
        year: Number(dateTimeSpecification.slice(0, 4)),
        month: Number(dateTimeSpecification.slice(5, 7)) - 1,
        date: Number(dateTimeSpecification.slice(8, 10)),
        hours: hours !== '' ? Number(hours) : undefined,
        minutes: minutes !== '' ? Number(minutes) : undefined,
    };
};

let NumberRangeError$1 = class NumberRangeError extends Error {
    constructor(min, max) {
        super(`Number must be between ${min} and ${max}.`);
        Object.defineProperty(this, "min", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: min
        });
        Object.defineProperty(this, "max", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: max
        });
    }
};

const doubleDigit$1 = (number) => {
    if (number < 0 || number > 99)
        throw new NumberRangeError$1(0, 99);
    return String(number).padStart(2, '0');
};

const toDateString$2 = (date) => {
    return `${date.getFullYear()}-${doubleDigit$1(date.getMonth() + 1)}-${doubleDigit$1(date.getDate())}`;
};
const toTimeString$1 = (date) => {
    return `${doubleDigit$1(date.getHours())}:${doubleDigit$1(date.getMinutes())}`;
};
const toDateTimeString$2 = (date) => {
    return `${toDateString$2(date)} ${toTimeString$1(date)}`;
};

class InvalidTimeStringError extends Error {
    constructor(timeString) {
        super(`Invalid time string: ${timeString}`);
    }
}

const minuteTimePointMultiplier = 1.6666666666666667; // 100 / 60
const timePointsFromString = (timeString) => {
    if (!timeStringRegex.test(timeString) && timeString !== '24:00')
        throw new InvalidTimeStringError(timeString);
    const [hoursInt, minutesInt] = timeString
        .split(':')
        .map((time) => parseInt(time, 10));
    let minutePoints = (minutesInt * minuteTimePointMultiplier).toString();
    if (minutePoints.split('.')[0].length < 2)
        minutePoints = `0${minutePoints}`;
    return Number(hoursInt + minutePoints);
};

const dateFromDateTime = (dateTime) => {
    return dateTime.slice(0, 10);
};
const timeFromDateTime = (dateTime) => {
    return dateTime.slice(11);
};

var WeekDay$1;
(function (WeekDay) {
    WeekDay[WeekDay["SUNDAY"] = 0] = "SUNDAY";
    WeekDay[WeekDay["MONDAY"] = 1] = "MONDAY";
    WeekDay[WeekDay["TUESDAY"] = 2] = "TUESDAY";
    WeekDay[WeekDay["WEDNESDAY"] = 3] = "WEDNESDAY";
    WeekDay[WeekDay["THURSDAY"] = 4] = "THURSDAY";
    WeekDay[WeekDay["FRIDAY"] = 5] = "FRIDAY";
    WeekDay[WeekDay["SATURDAY"] = 6] = "SATURDAY";
})(WeekDay$1 || (WeekDay$1 = {}));

WeekDay$1.MONDAY;
const DEFAULT_EVENT_COLOR_NAME = 'primary';

class CalendarEventImpl {
    constructor(_config, id, start, end, title, people, location, description, calendarId, _options = undefined, _customContent = {}, _foreignProperties = {}) {
        Object.defineProperty(this, "_config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _config
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: id
        });
        Object.defineProperty(this, "start", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: start
        });
        Object.defineProperty(this, "end", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: end
        });
        Object.defineProperty(this, "title", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: title
        });
        Object.defineProperty(this, "people", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: people
        });
        Object.defineProperty(this, "location", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: location
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: description
        });
        Object.defineProperty(this, "calendarId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: calendarId
        });
        Object.defineProperty(this, "_options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _options
        });
        Object.defineProperty(this, "_customContent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _customContent
        });
        Object.defineProperty(this, "_foreignProperties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _foreignProperties
        });
        Object.defineProperty(this, "_previousConcurrentEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_totalConcurrentEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_maxConcurrentEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_nDaysInGrid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_createdAt", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_eventFragments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    get _isSingleDayTimed() {
        return (dateTimeStringRegex.test(this.start) &&
            dateTimeStringRegex.test(this.end) &&
            dateFromDateTime(this.start) === dateFromDateTime(this.end));
    }
    get _isSingleDayFullDay() {
        return (dateStringRegex.test(this.start) &&
            dateStringRegex.test(this.end) &&
            this.start === this.end);
    }
    get _isMultiDayTimed() {
        return (dateTimeStringRegex.test(this.start) &&
            dateTimeStringRegex.test(this.end) &&
            dateFromDateTime(this.start) !== dateFromDateTime(this.end));
    }
    get _isMultiDayFullDay() {
        return (dateStringRegex.test(this.start) &&
            dateStringRegex.test(this.end) &&
            this.start !== this.end);
    }
    get _isSingleHybridDayTimed() {
        if (!this._config.isHybridDay)
            return false;
        if (!dateTimeStringRegex.test(this.start) ||
            !dateTimeStringRegex.test(this.end))
            return false;
        const startDate = dateFromDateTime(this.start);
        const endDate = dateFromDateTime(this.end);
        const endDateMinusOneDay = toDateString$2(new Date(toJSDate$1(endDate).getTime() - 86400000));
        if (startDate !== endDate && startDate !== endDateMinusOneDay)
            return false;
        const dayBoundaries = this._config.dayBoundaries.value;
        const eventStartTimePoints = timePointsFromString(timeFromDateTime(this.start));
        const eventEndTimePoints = timePointsFromString(timeFromDateTime(this.end));
        return ((eventStartTimePoints >= dayBoundaries.start &&
            (eventEndTimePoints <= dayBoundaries.end ||
                eventEndTimePoints > eventStartTimePoints)) ||
            (eventStartTimePoints < dayBoundaries.end &&
                eventEndTimePoints <= dayBoundaries.end));
    }
    get _color() {
        if (this.calendarId &&
            this._config.calendars.value &&
            this.calendarId in this._config.calendars.value) {
            return this._config.calendars.value[this.calendarId].colorName;
        }
        return DEFAULT_EVENT_COLOR_NAME;
    }
    _getForeignProperties() {
        return this._foreignProperties;
    }
    _getExternalEvent() {
        return {
            id: this.id,
            start: this.start,
            end: this.end,
            title: this.title,
            people: this.people,
            location: this.location,
            description: this.description,
            calendarId: this.calendarId,
            _options: this._options,
            ...this._getForeignProperties(),
        };
    }
}

class CalendarEventBuilder {
    constructor(_config, id, start, end) {
        Object.defineProperty(this, "_config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _config
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: id
        });
        Object.defineProperty(this, "start", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: start
        });
        Object.defineProperty(this, "end", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: end
        });
        Object.defineProperty(this, "people", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "location", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "title", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "calendarId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_foreignProperties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        Object.defineProperty(this, "_customContent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    build() {
        return new CalendarEventImpl(this._config, this.id, this.start, this.end, this.title, this.people, this.location, this.description, this.calendarId, this._options, this._customContent, this._foreignProperties);
    }
    withTitle(title) {
        this.title = title;
        return this;
    }
    withPeople(people) {
        this.people = people;
        return this;
    }
    withLocation(location) {
        this.location = location;
        return this;
    }
    withDescription(description) {
        this.description = description;
        return this;
    }
    withForeignProperties(foreignProperties) {
        this._foreignProperties = foreignProperties;
        return this;
    }
    withCalendarId(calendarId) {
        this.calendarId = calendarId;
        return this;
    }
    withOptions(options) {
        this._options = options;
        return this;
    }
    withCustomContent(customContent) {
        this._customContent = customContent;
        return this;
    }
}

const deepCloneEvent = (calendarEvent, $app) => {
    const calendarEventInternal = new CalendarEventBuilder($app.config, calendarEvent.id, calendarEvent.start, calendarEvent.end)
        .withTitle(calendarEvent.title)
        .withPeople(calendarEvent.people)
        .withCalendarId(calendarEvent.calendarId)
        .withForeignProperties(JSON.parse(JSON.stringify(calendarEvent._getForeignProperties())))
        .withLocation(calendarEvent.location)
        .withDescription(calendarEvent.description)
        .withOptions(calendarEvent._options)
        .withCustomContent(calendarEvent._customContent)
        .build();
    calendarEventInternal._nDaysInGrid = calendarEvent._nDaysInGrid;
    return calendarEventInternal;
};

const concatenatePeople = (people) => {
    return people.reduce((acc, person, index) => {
        if (index === 0)
            return person;
        if (index === people.length - 1)
            return `${acc} & ${person}`;
        return `${acc}, ${person}`;
    }, '');
};

const dateFn$1 = (dateTimeString, locale) => {
    const { year, month, date } = toIntegers$1(dateTimeString);
    return new Date(year, month, date).toLocaleDateString(locale, {
        day: 'numeric',
        month: 'long',
        year: 'numeric',
    });
};
const timeFn = (dateTimeString, locale) => {
    const { year, month, date, hours, minutes } = toIntegers$1(dateTimeString);
    return new Date(year, month, date, hours, minutes).toLocaleTimeString(locale, {
        hour: 'numeric',
        minute: 'numeric',
    });
};
const getTimeStamp = (calendarEvent, // to facilitate testing. In reality, we will always have a full CalendarEventInternal
locale, delimiter = '\u2013') => {
    const eventTime = { start: calendarEvent.start, end: calendarEvent.end };
    if (calendarEvent._isSingleDayFullDay) {
        return dateFn$1(eventTime.start, locale);
    }
    if (calendarEvent._isMultiDayFullDay) {
        return `${dateFn$1(eventTime.start, locale)} ${delimiter} ${dateFn$1(eventTime.end, locale)}`;
    }
    if (calendarEvent._isSingleDayTimed && eventTime.start !== eventTime.end) {
        return `${dateFn$1(eventTime.start, locale)} <span aria-hidden="true">⋅</span> ${timeFn(eventTime.start, locale)} ${delimiter} ${timeFn(eventTime.end, locale)}`;
    }
    if (calendarEvent._isSingleDayTimed &&
        calendarEvent.start === calendarEvent.end) {
        return `${dateFn$1(eventTime.start, locale)}, ${timeFn(eventTime.start, locale)}`;
    }
    return `${dateFn$1(eventTime.start, locale)}, ${timeFn(eventTime.start, locale)} ${delimiter} ${dateFn$1(eventTime.end, locale)}, ${timeFn(eventTime.end, locale)}`;
};

/**
 * Can be used for generating a random id for an entity
 * Should, however, never be used in potentially resource intense loops,
 * since the performance cost of this compared to new Date().getTime() is ca x4 in v8
 * */
const randomStringId$2 = () => 's' + Math.random().toString(36).substring(2, 11);
const addMinutes = (to, nMinutes) => {
    const { year, month, date, hours, minutes } = toIntegers$1(to);
    const isDateTimeString = hours !== undefined && minutes !== undefined;
    const jsDate = new Date(year, month, date, hours !== null && hours !== void 0 ? hours : 0, minutes !== null && minutes !== void 0 ? minutes : 0);
    jsDate.setMinutes(jsDate.getMinutes() + nMinutes);
    if (isDateTimeString) {
        return toDateTimeString$2(jsDate);
    }
    return toDateString$2(jsDate);
};

const createClickOutsideListener = ($app, modalId, withCallback) => {
    return function (e) {
        const modalPlugin = $app.config.plugins
            .eventModal;
        if (modalPlugin.config.preventClosingOnClickOutside)
            return;
        if (!(e.target instanceof HTMLElement))
            return;
        if (e.target.closest(`#${modalId}`))
            return;
        if (e.target.closest('.sx__interactive-event-modal__header'))
            return;
        if (e.target.closest('.sx__date-picker-popup'))
            return;
        if (e.target.closest('.sx__time-picker-popup'))
            return;
        if (e.target.closest('.sx__modal-delete-actions'))
            return;
        if (e.target.closest('.sx__event-form'))
            return;
        if (e.target.closest('.sx__app-combobox__list'))
            return;
        if (e.target.closest('.sx__app-select__list'))
            return;
        $app.config.plugins.eventModal.close();
        withCallback();
    };
};

const setPosition = (appDOMRect, eventDOMRect, modalHeight = 600, modalWidth = 540) => {
    eventDOMRect || (eventDOMRect = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        height: 0,
        width: 0,
        x: 0,
        y: 0,
        toJSON() { },
    });
    const MODAL_WIDTH = modalWidth;
    const INLINE_SPACE_BETWEEN_MODAL_AND_EVENT = 10;
    const WIDTH_NEEDED = MODAL_WIDTH + INLINE_SPACE_BETWEEN_MODAL_AND_EVENT;
    const hasSpaceTop = eventDOMRect.bottom - appDOMRect.top > modalHeight;
    const eventBottomLessThanAppBottom = eventDOMRect.bottom < appDOMRect.bottom;
    const eventTopLessThanAppTop = eventDOMRect.top < appDOMRect.top;
    let top = 0;
    let left = 0;
    let animationStart = '0%';
    if (appDOMRect.bottom - eventDOMRect.top > modalHeight &&
        !eventTopLessThanAppTop) {
        top = eventDOMRect.top;
    }
    else if (hasSpaceTop && eventBottomLessThanAppBottom) {
        top = eventDOMRect.bottom - modalHeight;
    }
    else if (hasSpaceTop && !eventBottomLessThanAppBottom) {
        top = appDOMRect.bottom - modalHeight;
    }
    else {
        top = appDOMRect.top;
    }
    if (appDOMRect.right - eventDOMRect.right > WIDTH_NEEDED) {
        left = eventDOMRect.right + INLINE_SPACE_BETWEEN_MODAL_AND_EVENT;
        animationStart = '-10%';
    }
    else if (eventDOMRect.left - appDOMRect.left > WIDTH_NEEDED) {
        left = eventDOMRect.left - WIDTH_NEEDED;
        animationStart = '10%';
    }
    else {
        left = appDOMRect.left;
    }
    document.documentElement.style.setProperty('--sx-event-modal-animation-start', animationStart);
    document.documentElement.style.setProperty('--sx-event-modal-top', `${top}px`);
    document.documentElement.style.setProperty('--sx-event-modal-left', `${left}px`);
};

function EditIcon({ color }) {
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("svg", { className: "sx__modal-edit-icon", xmlns: "http://www.w3.org/2000/svg", height: "24", viewBox: "0 -960 960 960", width: "24", children: jsxRuntime.jsx("path", { fill: color, d: "M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z" }) }) }));
}

function TrashIcon({ color }) {
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("svg", { className: "sx__modal-trash-icon", xmlns: "http://www.w3.org/2000/svg", height: "24", viewBox: "0 -960 960 960", width: "24", children: jsxRuntime.jsx("path", { fill: color, d: "M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z" }) }) }));
}

const useIconColors = ($app) => {
    const ICON_COLOR_LIGHT_MODE = '#000';
    const ICON_COLOR_DARK_MODE = 'var(--sx-color-neutral-variant)';
    const iconColor = signals.signal($app.calendarState.isDark.value
        ? ICON_COLOR_DARK_MODE
        : ICON_COLOR_LIGHT_MODE);
    signals.effect(() => {
        if ($app.calendarState.isDark.value)
            iconColor.value = ICON_COLOR_DARK_MODE;
        else
            iconColor.value = ICON_COLOR_LIGHT_MODE;
    });
    return iconColor;
};

var ViewLevel;
(function (ViewLevel) {
    ViewLevel["HOURLY"] = "hourly";
    ViewLevel["DAILY"] = "daily";
})(ViewLevel || (ViewLevel = {}));

function EventDisplay({ $app, calendarEvent }) {
    const iconColor = useIconColors($app);
    const modalPlugin = $app.config.plugins
        .eventModal;
    const isEventEditable = typeof modalPlugin.isEventEditable === 'function'
        ? modalPlugin.isEventEditable(calendarEvent)
        : true;
    const currentViewIsResource = $app.calendarState.view.value === ViewLevel.HOURLY ||
        $app.calendarState.view.value === ViewLevel.DAILY;
    let resourceColorName = undefined;
    if (currentViewIsResource) {
        const resourceDefinition = $app.resourceViewConfig.resources.value.find((r) => r.id === calendarEvent._getForeignProperties().resourceId);
        resourceColorName = (resourceDefinition === null || resourceDefinition === void 0 ? void 0 : resourceDefinition.colorName) || 'primary';
    }
    const eventColorName = resourceColorName || calendarEvent._color;
    const openForm = () => {
        let originalEvent = undefined;
        modalPlugin.isEditingRecurringEvent.value = false;
        if (calendarEvent.isCopy ||
            ('rrule' in calendarEvent._getForeignProperties() &&
                calendarEvent._getForeignProperties().rrule)) {
            originalEvent = $app.calendarEvents.list.value.find((event) => event.id === calendarEvent.id && !event.isCopy);
            modalPlugin.isEditingRecurringEvent.value = true;
        }
        modalPlugin.formValues.value = deepCloneEvent(originalEvent || calendarEvent, $app)._getExternalEvent();
        // hide modal before showing it again. This will make the transition smoother when repositioning the modal
        modalPlugin.isOpen.value = false;
        modalPlugin.modalState.value = 'edit';
        setTimeout(() => {
            modalPlugin.isOpen.value = true;
        }, 100);
    };
    const openDeleteActions = () => {
        modalPlugin.modalState.value = 'delete';
    };
    const additionalFields = $app.config._customComponentFns.interactiveModalAdditionalFields;
    const additionalFieldsId = hooks.useState(additionalFields ? randomStringId$2() : undefined)[0];
    hooks.useEffect(() => {
        if (additionalFields) {
            additionalFields(document.querySelector(`[data-ccid="${additionalFieldsId}"]`), {
                calendarEvent,
            });
        }
    }, []);
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs(preact.Fragment, { children: [isEventEditable && (jsxRuntime.jsxs("header", { className: "sx__interactive-event-modal__header", children: [jsxRuntime.jsx("button", { className: "sx__modal-action-button", onClick: openForm, children: jsxRuntime.jsx(EditIcon, { color: 'rgb(128, 128, 128)' }) }), jsxRuntime.jsx("button", { className: "sx__modal-action-button", onClick: openDeleteActions, children: jsxRuntime.jsx(TrashIcon, { color: 'rgb(128, 128, 128)' }) })] })), jsxRuntime.jsxs("div", { className: "sx__has-icon sx__event-modal__title", children: [jsxRuntime.jsx("div", { style: {
                                backgroundColor: `var(--sx-color-${eventColorName}-container)`,
                            }, "data-color": eventColorName, className: "sx__interactive-event-modal__color-icon sx__event-icon" }), calendarEvent.title] }), jsxRuntime.jsxs("div", { className: "sx__has-icon sx__interactive-event-modal__time", children: [jsxRuntime.jsx(TimeIcon, { strokeColor: iconColor.value }), jsxRuntime.jsx("div", { dangerouslySetInnerHTML: {
                                __html: getTimeStamp(calendarEvent, $app.config.locale.value),
                            } })] }), Array.isArray(calendarEvent.people) &&
                    calendarEvent.people.length > 0 && (jsxRuntime.jsxs("div", { className: "sx__has-icon sx__interactive-event-modal__people", children: [jsxRuntime.jsx(UserIcon, { strokeColor: iconColor.value }), concatenatePeople(calendarEvent.people)] })), calendarEvent.location && (jsxRuntime.jsxs("div", { className: "sx__has-icon sx__interactive-event-modal__location", children: [jsxRuntime.jsx(LocationPinIcon, { strokeColor: iconColor.value }), calendarEvent.location] })), calendarEvent.description && (jsxRuntime.jsxs("div", { className: "sx__has-icon sx__interactive-event-modal__description", children: [jsxRuntime.jsx(DescriptionIcon, { strokeColor: iconColor.value }), calendarEvent.description] })), additionalFields && (jsxRuntime.jsx("div", { "data-ccid": additionalFieldsId, className: "sx__interactive-event-modal__additional-fields" }))] }) }));
}

function TextField({ initialValue, onChange, label, fieldName, id, errorMessage, placeholder, }) {
    const [inputValue, setInputValue] = hooks.useState(initialValue);
    const handleInput = (newValue) => {
        setInputValue(newValue);
        onChange(newValue);
    };
    const BASE_WRAPPER_CLASS = 'sx__text-field-wrapper';
    const [wrapperClasses, setWrapperClasses] = hooks.useState([BASE_WRAPPER_CLASS]);
    hooks.useEffect(() => {
        if (inputValue.length > 0) {
            if (!wrapperClasses.includes('sx__has-value')) {
                setWrapperClasses([BASE_WRAPPER_CLASS, 'sx__has-value']);
            }
        }
        else {
            if (wrapperClasses.includes('sx__has-value')) {
                setWrapperClasses([BASE_WRAPPER_CLASS]);
            }
        }
    }, [inputValue]);
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { class: "sx__form-field", children: [jsxRuntime.jsxs("div", { className: wrapperClasses.join(' '), children: [jsxRuntime.jsx("input", { id: id, className: 'sx__text-field-input', value: inputValue, onInput: (e) => handleInput(e.currentTarget.value), name: fieldName, type: "text", placeholder: placeholder }), jsxRuntime.jsx("label", { className: 'sx__text-field-label', htmlFor: fieldName, children: label })] }), errorMessage && jsxRuntime.jsx("p", { className: "sx__error-message", children: errorMessage })] }) }));
}

function AppButton({ onClick, children, additionalClasses, }) {
    return (jsxRuntime.jsx("button", { className: 'sx__app-button' + (additionalClasses ? ` ${additionalClasses}` : ''), onClick: onClick, children: children }));
}

const AppContext$1 = preact.createContext({});

const DateFormats = {
    DATE_STRING: /^\d{4}-\d{2}-\d{2}$/,
    DATE_TIME_STRING: /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/,
};

class InvalidDateTimeError extends Error {
    constructor(dateTimeSpecification) {
        super(`Invalid date time specification: ${dateTimeSpecification}`);
    }
}

const toJSDate = (dateTimeSpecification) => {
    if (!DateFormats.DATE_TIME_STRING.test(dateTimeSpecification) &&
        !DateFormats.DATE_STRING.test(dateTimeSpecification))
        throw new InvalidDateTimeError(dateTimeSpecification);
    return new Date(Number(dateTimeSpecification.slice(0, 4)), Number(dateTimeSpecification.slice(5, 7)) - 1, Number(dateTimeSpecification.slice(8, 10)), Number(dateTimeSpecification.slice(11, 13)), // for date strings this will be 0
    Number(dateTimeSpecification.slice(14, 16)) // for date strings this will be 0
    );
};
const toIntegers = (dateTimeSpecification) => {
    const hours = dateTimeSpecification.slice(11, 13), minutes = dateTimeSpecification.slice(14, 16);
    return {
        year: Number(dateTimeSpecification.slice(0, 4)),
        month: Number(dateTimeSpecification.slice(5, 7)) - 1,
        date: Number(dateTimeSpecification.slice(8, 10)),
        hours: hours !== '' ? Number(hours) : undefined,
        minutes: minutes !== '' ? Number(minutes) : undefined,
    };
};

const toLocalizedMonth = (date, locale) => {
    return date.toLocaleString(locale, { month: 'long' });
};
const toLocalizedDateString = (date, locale) => {
    return date.toLocaleString(locale, {
        month: 'numeric',
        day: 'numeric',
        year: 'numeric',
    });
};
const getOneLetterDayNames = (week, locale) => {
    return week.map((date) => {
        return date.toLocaleString(locale, { weekday: 'short' }).charAt(0);
    });
};
const getDayNameShort = (date, locale) => {
    if (locale === 'he-IL') {
        return date.toLocaleString(locale, { weekday: 'narrow' });
    }
    return date.toLocaleString(locale, { weekday: 'short' });
};
const getDayNamesShort = (week, locale) => {
    return week.map((date) => getDayNameShort(date, locale));
};
const getOneLetterOrShortDayNames = (week, locale) => {
    if (['zh-cn', 'zh-tw', 'ca-es', 'he-il'].includes(locale.toLowerCase())) {
        return getDayNamesShort(week, locale);
    }
    return getOneLetterDayNames(week, locale);
};

var img = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='utf-8'%3f%3e%3c!-- Uploaded to: SVG Repo%2c www.svgrepo.com%2c Generator: SVG Repo Mixer Tools --%3e%3csvg width='800px' height='800px' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M6 9L12 15L18 9' stroke='%23DED8E1' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e";

/**
 * Can be used for generating a random id for an entity
 * Should, however, never be used in potentially resource intense loops,
 * since the performance cost of this compared to new Date().getTime() is ca x4 in v8
 * */
const randomStringId$1 = () => 's' + Math.random().toString(36).substring(2, 11);

const isKeyEnterOrSpace = (keyboardEvent) => keyboardEvent.key === 'Enter' || keyboardEvent.key === ' ';

function AppInput$1() {
    const datePickerInputId = randomStringId$1();
    const datePickerLabelId = randomStringId$1();
    const inputWrapperId = randomStringId$1();
    const $app = hooks.useContext(AppContext$1);
    const getLocalizedDate = (dateString) => {
        if (dateString === '')
            return $app.translate('MM/DD/YYYY');
        return toLocalizedDateString(toJSDate(dateString), $app.config.locale.value);
    };
    hooks.useEffect(() => {
        $app.datePickerState.inputDisplayedValue.value = getLocalizedDate($app.datePickerState.selectedDate.value);
    }, [$app.datePickerState.selectedDate.value, $app.config.locale.value]);
    const [wrapperClasses, setWrapperClasses] = hooks.useState([]);
    const setInputElement = () => {
        const inputWrapperEl = document.getElementById(inputWrapperId);
        $app.datePickerState.inputWrapperElement.value =
            inputWrapperEl instanceof HTMLDivElement ? inputWrapperEl : undefined;
    };
    hooks.useEffect(() => {
        if ($app.config.teleportTo)
            setInputElement();
        const newClasses = ['sx__date-input-wrapper'];
        if ($app.datePickerState.isOpen.value)
            newClasses.push('sx__date-input--active');
        setWrapperClasses(newClasses);
    }, [$app.datePickerState.isOpen.value]);
    const handleKeyUp = (event) => {
        if (event.key === 'Enter')
            handleInputValue(event);
    };
    const handleInputValue = (event) => {
        event.stopPropagation(); // prevent date picker from closing
        try {
            $app.datePickerState.inputDisplayedValue.value = event.target.value;
            $app.datePickerState.close();
        }
        catch (e) {
            console.log('Error setting input value:' + e);
        }
    };
    hooks.useEffect(() => {
        const inputElement = document.getElementById(datePickerInputId);
        if (inputElement === null)
            return;
        inputElement.addEventListener('change', handleInputValue); // Preact onChange triggers on every input
        return () => inputElement.removeEventListener('change', handleInputValue);
    });
    const handleClick = (event) => {
        handleInputValue(event);
        $app.datePickerState.open();
    };
    const handleButtonKeyDown = (keyboardEvent) => {
        if (isKeyEnterOrSpace(keyboardEvent)) {
            keyboardEvent.preventDefault();
            $app.datePickerState.open();
            setTimeout(() => {
                const element = document.querySelector('[data-focus="true"]');
                if (element instanceof HTMLElement)
                    element.focus();
            }, 50);
        }
    };
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { className: wrapperClasses.join(' '), id: inputWrapperId, children: [jsxRuntime.jsx("label", { for: datePickerInputId, id: datePickerLabelId, className: "sx__date-input-label", children: $app.config.label || $app.translate('Date') }), jsxRuntime.jsx("input", { id: datePickerInputId, tabIndex: $app.datePickerState.isDisabled.value ? -1 : 0, name: $app.config.name || 'date', "aria-describedby": datePickerLabelId, value: $app.datePickerState.inputDisplayedValue.value, "data-testid": "date-picker-input", className: "sx__date-input", onClick: handleClick, onKeyUp: handleKeyUp, type: "text" }), jsxRuntime.jsx("button", { type: "button", tabIndex: $app.datePickerState.isDisabled.value ? -1 : 0, "aria-label": $app.translate('Choose Date'), onKeyDown: handleButtonKeyDown, onClick: () => $app.datePickerState.open(), className: "sx__date-input-chevron-wrapper", children: jsxRuntime.jsx("img", { className: "sx__date-input-chevron", src: img, alt: "" }) })] }) }));
}

var DatePickerView;
(function (DatePickerView) {
    DatePickerView["MONTH_DAYS"] = "month-days";
    DatePickerView["YEARS"] = "years";
})(DatePickerView || (DatePickerView = {}));

const YEARS_VIEW = 'years-view';
const MONTH_VIEW = 'months-view';
const DATE_PICKER_WEEK = 'date-picker-week';

class NumberRangeError extends Error {
    constructor(min, max) {
        super(`Number must be between ${min} and ${max}.`);
        Object.defineProperty(this, "min", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: min
        });
        Object.defineProperty(this, "max", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: max
        });
    }
}

const doubleDigit = (number) => {
    if (number < 0 || number > 99)
        throw new NumberRangeError(0, 99);
    return String(number).padStart(2, '0');
};

const toDateString$1 = (date) => {
    return `${date.getFullYear()}-${doubleDigit(date.getMonth() + 1)}-${doubleDigit(date.getDate())}`;
};
const toTimeString = (date) => {
    return `${doubleDigit(date.getHours())}:${doubleDigit(date.getMinutes())}`;
};
const toDateTimeString$1 = (date) => {
    return `${toDateString$1(date)} ${toTimeString(date)}`;
};

const addMonths = (to, nMonths) => {
    const { year, month, date, hours, minutes } = toIntegers(to);
    const isDateTimeString = hours !== undefined && minutes !== undefined;
    const jsDate = new Date(year, month, date, hours !== null && hours !== void 0 ? hours : 0, minutes !== null && minutes !== void 0 ? minutes : 0);
    let expectedMonth = (jsDate.getMonth() + nMonths) % 12;
    if (expectedMonth < 0)
        expectedMonth += 12;
    jsDate.setMonth(jsDate.getMonth() + nMonths);
    // handle date overflow and underflow
    if (jsDate.getMonth() > expectedMonth) {
        jsDate.setDate(0);
    }
    else if (jsDate.getMonth() < expectedMonth) {
        jsDate.setMonth(jsDate.getMonth() + 1);
        jsDate.setDate(0);
    }
    if (isDateTimeString) {
        return toDateTimeString$1(jsDate);
    }
    return toDateString$1(jsDate);
};
const addDays = (to, nDays) => {
    const { year, month, date, hours, minutes } = toIntegers(to);
    const isDateTimeString = hours !== undefined && minutes !== undefined;
    const jsDate = new Date(year, month, date, hours !== null && hours !== void 0 ? hours : 0, minutes !== null && minutes !== void 0 ? minutes : 0);
    jsDate.setDate(jsDate.getDate() + nDays);
    if (isDateTimeString) {
        return toDateTimeString$1(jsDate);
    }
    return toDateString$1(jsDate);
};

const setDateOfMonth = (dateString, date) => {
    dateString = dateString.slice(0, 8) + doubleDigit(date) + dateString.slice(10);
    return dateString;
};
const getFirstDayOPreviousMonth = (dateString) => {
    dateString = addMonths(dateString, -1);
    return setDateOfMonth(dateString, 1);
};
const getFirstDayOfNextMonth = (dateString) => {
    dateString = addMonths(dateString, 1);
    return setDateOfMonth(dateString, 1);
};

function Chevron({ direction, onClick, buttonText, disabled = false, }) {
    const handleKeyDown = (keyboardEvent) => {
        if (isKeyEnterOrSpace(keyboardEvent))
            onClick();
    };
    return (jsxRuntime.jsx("button", { type: "button", disabled: disabled, className: "sx__chevron-wrapper sx__ripple", onMouseUp: onClick, onKeyDown: handleKeyDown, tabIndex: 0, children: jsxRuntime.jsx("i", { className: `sx__chevron sx__chevron--${direction}`, children: buttonText }) }));
}

function MonthViewHeader({ setYearsView }) {
    const $app = hooks.useContext(AppContext$1);
    const dateStringToLocalizedMonthName = (selectedDate) => {
        const selectedDateJS = toJSDate(selectedDate);
        return toLocalizedMonth(selectedDateJS, $app.config.locale.value);
    };
    const getYearFrom = (datePickerDate) => {
        return toIntegers(datePickerDate).year;
    };
    const [selectedDateMonthName, setSelectedDateMonthName] = hooks.useState(dateStringToLocalizedMonthName($app.datePickerState.datePickerDate.value));
    const [datePickerYear, setDatePickerYear] = hooks.useState(getYearFrom($app.datePickerState.datePickerDate.value));
    const setPreviousMonth = () => {
        $app.datePickerState.datePickerDate.value = getFirstDayOPreviousMonth($app.datePickerState.datePickerDate.value);
    };
    const setNextMonth = () => {
        $app.datePickerState.datePickerDate.value = getFirstDayOfNextMonth($app.datePickerState.datePickerDate.value);
    };
    hooks.useEffect(() => {
        setSelectedDateMonthName(dateStringToLocalizedMonthName($app.datePickerState.datePickerDate.value));
        setDatePickerYear(getYearFrom($app.datePickerState.datePickerDate.value));
    }, [$app.datePickerState.datePickerDate.value]);
    const handleOpenYearsView = (e) => {
        e.stopPropagation();
        setYearsView();
    };
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("header", { className: "sx__date-picker__month-view-header", children: [jsxRuntime.jsx(Chevron, { direction: 'previous', onClick: () => setPreviousMonth(), buttonText: $app.translate('Previous month') }), jsxRuntime.jsx("button", { type: "button", className: "sx__date-picker__month-view-header__month-year", onClick: (event) => handleOpenYearsView(event), children: selectedDateMonthName + ' ' + datePickerYear }), jsxRuntime.jsx(Chevron, { direction: 'next', onClick: () => setNextMonth(), buttonText: $app.translate('Next month') })] }) }));
}

function DayNames() {
    const $app = hooks.useContext(AppContext$1);
    const aWeek = $app.timeUnitsImpl.getWeekFor(toJSDate($app.datePickerState.datePickerDate.value));
    const dayNames = getOneLetterOrShortDayNames(aWeek, $app.config.locale.value);
    return (jsxRuntime.jsx("div", { className: "sx__date-picker__day-names", children: dayNames.map((dayName) => (jsxRuntime.jsx("span", { "data-testid": "day-name", className: "sx__date-picker__day-name", children: dayName }))) }));
}

const isToday = (date) => {
    const today = new Date();
    return (date.getDate() === today.getDate() &&
        date.getMonth() === today.getMonth() &&
        date.getFullYear() === today.getFullYear());
};
const isSameMonth = (date1, date2) => {
    return (date1.getMonth() === date2.getMonth() &&
        date1.getFullYear() === date2.getFullYear());
};

var WeekDay;
(function (WeekDay) {
    WeekDay[WeekDay["SUNDAY"] = 0] = "SUNDAY";
    WeekDay[WeekDay["MONDAY"] = 1] = "MONDAY";
    WeekDay[WeekDay["TUESDAY"] = 2] = "TUESDAY";
    WeekDay[WeekDay["WEDNESDAY"] = 3] = "WEDNESDAY";
    WeekDay[WeekDay["THURSDAY"] = 4] = "THURSDAY";
    WeekDay[WeekDay["FRIDAY"] = 5] = "FRIDAY";
    WeekDay[WeekDay["SATURDAY"] = 6] = "SATURDAY";
})(WeekDay || (WeekDay = {}));

const DEFAULT_LOCALE = 'en-US';
const DEFAULT_FIRST_DAY_OF_WEEK = WeekDay.MONDAY;

const dateFn = (dateTimeString, locale) => {
    const { year, month, date } = toIntegers(dateTimeString);
    return new Date(year, month, date).toLocaleDateString(locale, {
        day: 'numeric',
        month: 'long',
        year: 'numeric',
    });
};
const getLocalizedDate = dateFn;

function MonthViewWeek({ week }) {
    const $app = hooks.useContext(AppContext$1);
    const weekDays = week.map((day) => {
        const classes = ['sx__date-picker__day'];
        if (isToday(day))
            classes.push('sx__date-picker__day--today');
        if (toDateString$1(day) === $app.datePickerState.selectedDate.value)
            classes.push('sx__date-picker__day--selected');
        if (!isSameMonth(day, toJSDate($app.datePickerState.datePickerDate.value)))
            classes.push('is-leading-or-trailing');
        return {
            day,
            classes,
        };
    });
    const isDateSelectable = (date) => {
        const dateString = toDateString$1(date);
        return dateString >= $app.config.min && dateString <= $app.config.max;
    };
    const selectDate = (date) => {
        $app.datePickerState.selectedDate.value = toDateString$1(date);
        $app.datePickerState.close();
    };
    const hasFocus = (weekDay) => toDateString$1(weekDay.day) === $app.datePickerState.datePickerDate.value;
    const handleKeyDown = (event) => {
        if (event.key === 'Enter') {
            $app.datePickerState.selectedDate.value =
                $app.datePickerState.datePickerDate.value;
            $app.datePickerState.close();
            return;
        }
        const keyMapDaysToAdd = new Map([
            ['ArrowDown', 7],
            ['ArrowUp', -7],
            ['ArrowLeft', -1],
            ['ArrowRight', 1],
        ]);
        $app.datePickerState.datePickerDate.value = addDays($app.datePickerState.datePickerDate.value, keyMapDaysToAdd.get(event.key) || 0);
    };
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { "data-testid": DATE_PICKER_WEEK, className: "sx__date-picker__week", children: weekDays.map((weekDay) => (jsxRuntime.jsx("button", { type: "button", tabIndex: hasFocus(weekDay) ? 0 : -1, disabled: !isDateSelectable(weekDay.day), "aria-label": getLocalizedDate($app.datePickerState.datePickerDate.value, $app.config.locale.value), className: weekDay.classes.join(' '), "data-focus": hasFocus(weekDay) ? 'true' : undefined, onClick: () => selectDate(weekDay.day), onKeyDown: handleKeyDown, children: weekDay.day.getDate() }))) }) }));
}

function MonthView({ seatYearsView }) {
    const elementId = randomStringId$1();
    const $app = hooks.useContext(AppContext$1);
    const [month, setMonth] = hooks.useState([]);
    const renderMonth = () => {
        const newDatePickerDate = toJSDate($app.datePickerState.datePickerDate.value);
        setMonth($app.timeUnitsImpl.getMonthWithTrailingAndLeadingDays(newDatePickerDate.getFullYear(), newDatePickerDate.getMonth()));
    };
    hooks.useEffect(() => {
        renderMonth();
    }, [$app.datePickerState.datePickerDate.value]);
    hooks.useEffect(() => {
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                const mutatedElement = mutation.target;
                if (mutatedElement.dataset.focus === 'true')
                    mutatedElement.focus();
            });
        });
        const monthViewElement = document.getElementById(elementId);
        observer.observe(monthViewElement, {
            childList: true,
            subtree: true,
            attributes: true,
        });
        return () => observer.disconnect();
    }, []);
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { id: elementId, "data-testid": MONTH_VIEW, className: "sx__date-picker__month-view", children: [jsxRuntime.jsx(MonthViewHeader, { setYearsView: seatYearsView }), jsxRuntime.jsx(DayNames, {}), month.map((week) => (jsxRuntime.jsx(MonthViewWeek, { week: week })))] }) }));
}

function YearsViewAccordion({ year, setYearAndMonth, isExpanded, expand, }) {
    const $app = hooks.useContext(AppContext$1);
    const yearWithDates = $app.timeUnitsImpl.getMonthsFor(year);
    const handleClickOnMonth = (event, month) => {
        event.stopPropagation();
        setYearAndMonth(year, month.getMonth());
    };
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("li", { className: isExpanded ? 'sx__is-expanded' : '', children: [jsxRuntime.jsx("button", { type: "button", className: "sx__date-picker__years-accordion__expand-button sx__ripple--wide", onClick: () => expand(year), children: year }), isExpanded && (jsxRuntime.jsx("div", { className: "sx__date-picker__years-view-accordion__panel", children: yearWithDates.map((month) => (jsxRuntime.jsx("button", { type: "button", className: "sx__date-picker__years-view-accordion__month", onClick: (event) => handleClickOnMonth(event, month), children: toLocalizedMonth(month, $app.config.locale.value) }))) }))] }) }));
}

function YearsView({ setMonthView }) {
    const $app = hooks.useContext(AppContext$1);
    const minYear = toJSDate($app.config.min).getFullYear();
    const maxYear = toJSDate($app.config.max).getFullYear();
    const years = Array.from({ length: maxYear - minYear + 1 }, (_, i) => minYear + i);
    const { year: selectedYear } = toIntegers($app.datePickerState.selectedDate.value);
    const [expandedYear, setExpandedYear] = hooks.useState(selectedYear);
    const setNewDatePickerDate = (year, month) => {
        $app.datePickerState.datePickerDate.value = toDateString$1(new Date(year, month, 1));
        setMonthView();
    };
    hooks.useEffect(() => {
        var _a;
        const initiallyExpandedYear = (_a = document
            .querySelector('.sx__date-picker__years-view')) === null || _a === void 0 ? void 0 : _a.querySelector('.sx__is-expanded');
        if (!initiallyExpandedYear)
            return;
        initiallyExpandedYear.scrollIntoView({
            block: 'center',
        });
    }, []);
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("ul", { className: "sx__date-picker__years-view", "data-testid": YEARS_VIEW, children: years.map((year) => (jsxRuntime.jsx(YearsViewAccordion, { year: year, setYearAndMonth: (year, month) => setNewDatePickerDate(year, month), isExpanded: expandedYear === year, expand: (year) => setExpandedYear(year) }))) }) }));
}

const isScrollable$2 = (el) => {
    if (el) {
        const hasScrollableContent = el.scrollHeight > el.clientHeight;
        const overflowYStyle = window.getComputedStyle(el).overflowY;
        const isOverflowHidden = overflowYStyle.indexOf('hidden') !== -1;
        return hasScrollableContent && !isOverflowHidden;
    }
    return true;
};
const getScrollableParents$2 = (el, acc = []) => {
    if (!el ||
        el === document.body ||
        el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        acc.push(window);
        return acc;
    }
    if (isScrollable$2(el)) {
        acc.push(el);
    }
    return getScrollableParents$2((el.assignedSlot
        ? el.assignedSlot.parentNode
        : el.parentNode), acc);
};

const POPUP_CLASS_NAME = 'sx__date-picker-popup';
function AppPopup$1() {
    const $app = hooks.useContext(AppContext$1);
    const [datePickerView, setDatePickerView] = hooks.useState(DatePickerView.MONTH_DAYS);
    const classList = hooks.useMemo(() => {
        const returnValue = [
            POPUP_CLASS_NAME,
            $app.datePickerState.isDark.value ? 'is-dark' : '',
            $app.config.teleportTo ? 'is-teleported' : '',
        ];
        if ($app.config.placement && !$app.config.teleportTo) {
            returnValue.push($app.config.placement);
        }
        return returnValue;
    }, [
        $app.datePickerState.isDark.value,
        $app.config.placement,
        $app.config.teleportTo,
    ]);
    const clickOutsideListener = (event) => {
        const target = event.target;
        if (!target.closest(`.${POPUP_CLASS_NAME}`))
            $app.datePickerState.close();
    };
    const escapeKeyListener = (e) => {
        if (e.key === 'Escape') {
            if ($app.config.listeners.onEscapeKeyDown)
                $app.config.listeners.onEscapeKeyDown($app);
            else
                $app.datePickerState.close();
        }
    };
    hooks.useEffect(() => {
        document.addEventListener('click', clickOutsideListener);
        document.addEventListener('keydown', escapeKeyListener);
        return () => {
            document.removeEventListener('click', clickOutsideListener);
            document.removeEventListener('keydown', escapeKeyListener);
        };
    }, []);
    const remSize = Number(getComputedStyle(document.documentElement).fontSize.split('px')[0]);
    const popupHeight = 362;
    const popupWidth = 332;
    const getFixedPositionStyles = () => {
        const inputWrapperEl = $app.datePickerState.inputWrapperElement.value;
        const inputRect = inputWrapperEl === null || inputWrapperEl === void 0 ? void 0 : inputWrapperEl.getBoundingClientRect();
        if (inputWrapperEl === undefined || !(inputRect instanceof DOMRect))
            return undefined;
        return {
            top: $app.config.placement.includes('bottom')
                ? inputRect.height + inputRect.y + 1 // 1px border
                : inputRect.y - remSize - popupHeight, // subtract remsize to leave room for label text
            left: $app.config.placement.includes('start')
                ? inputRect.x
                : inputRect.x + inputRect.width - popupWidth,
            width: popupWidth,
            position: 'fixed',
        };
    };
    const [fixedPositionStyle, setFixedPositionStyle] = hooks.useState(getFixedPositionStyles());
    hooks.useEffect(() => {
        const inputWrapper = $app.datePickerState.inputWrapperElement.value;
        if (inputWrapper === undefined)
            return;
        const scrollableParents = getScrollableParents$2(inputWrapper);
        const scrollListener = () => setFixedPositionStyle(getFixedPositionStyles());
        scrollableParents.forEach((parent) => parent.addEventListener('scroll', scrollListener));
        return () => scrollableParents.forEach((parent) => parent.removeEventListener('scroll', scrollListener));
    }, []);
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { style: $app.config.teleportTo ? fixedPositionStyle : undefined, "data-testid": "date-picker-popup", className: classList.join(' '), children: datePickerView === DatePickerView.MONTH_DAYS ? (jsxRuntime.jsx(MonthView, { seatYearsView: () => setDatePickerView(DatePickerView.YEARS) })) : (jsxRuntime.jsx(YearsView, { setMonthView: () => setDatePickerView(DatePickerView.MONTH_DAYS) })) }) }));
}

function AppWrapper({ $app }) {
    const initialClassList = ['sx__date-picker-wrapper'];
    const [classList, setClassList] = hooks.useState(initialClassList);
    hooks.useEffect(() => {
        var _a;
        const list = [...initialClassList];
        if ($app.datePickerState.isDark.value)
            list.push('is-dark');
        if ((_a = $app.config.style) === null || _a === void 0 ? void 0 : _a.fullWidth)
            list.push('has-full-width');
        if ($app.datePickerState.isDisabled.value)
            list.push('is-disabled');
        setClassList(list);
    }, [$app.datePickerState.isDark.value, $app.datePickerState.isDisabled.value]);
    let appPopupJSX = jsxRuntime.jsx(AppPopup$1, {});
    if ($app.config.teleportTo)
        appPopupJSX = compat.createPortal(appPopupJSX, $app.config.teleportTo);
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { className: classList.join(' '), children: jsxRuntime.jsxs(AppContext$1.Provider, { value: $app, children: [jsxRuntime.jsx(AppInput$1, {}), $app.datePickerState.isOpen.value && appPopupJSX] }) }) }));
}

class DatePickerApp {
    constructor($app) {
        Object.defineProperty(this, "$app", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: $app
        });
    }
    render(el) {
        preact.render(preact.createElement(AppWrapper, {
            $app: this.$app,
        }), el);
    }
    get value() {
        return this.$app.datePickerState.selectedDate.value;
    }
    set value(value) {
        this.$app.datePickerState.selectedDate.value = value;
    }
    get disabled() {
        return this.$app.datePickerState.isDisabled.value;
    }
    set disabled(value) {
        this.$app.datePickerState.isDisabled.value = value;
    }
    setTheme(theme) {
        this.$app.datePickerState.isDark.value = theme === 'dark';
    }
    getTheme() {
        return this.$app.datePickerState.isDark.value ? 'dark' : 'light';
    }
}

var Month;
(function (Month) {
    Month[Month["JANUARY"] = 0] = "JANUARY";
    Month[Month["FEBRUARY"] = 1] = "FEBRUARY";
    Month[Month["MARCH"] = 2] = "MARCH";
    Month[Month["APRIL"] = 3] = "APRIL";
    Month[Month["MAY"] = 4] = "MAY";
    Month[Month["JUNE"] = 5] = "JUNE";
    Month[Month["JULY"] = 6] = "JULY";
    Month[Month["AUGUST"] = 7] = "AUGUST";
    Month[Month["SEPTEMBER"] = 8] = "SEPTEMBER";
    Month[Month["OCTOBER"] = 9] = "OCTOBER";
    Month[Month["NOVEMBER"] = 10] = "NOVEMBER";
    Month[Month["DECEMBER"] = 11] = "DECEMBER";
})(Month || (Month = {}));

class NoYearZeroError extends Error {
    constructor() {
        super('Year zero does not exist in the Gregorian calendar.');
    }
}

class ExtendedDateImpl extends Date {
    constructor(yearArg, monthArg, dateArg) {
        super(yearArg, monthArg, dateArg);
        if (yearArg === 0)
            throw new NoYearZeroError();
        this.setFullYear(yearArg); // Overwrite the behavior of JS-Date, whose constructor does not allow years 0-99
    }
    get year() {
        return this.getFullYear();
    }
    get month() {
        return this.getMonth();
    }
    get date() {
        return this.getDate();
    }
}

class TimeUnitsImpl {
    constructor(config) {
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: config
        });
    }
    get firstDayOfWeek() {
        return this.config.firstDayOfWeek.value;
    }
    set firstDayOfWeek(firstDayOfWeek) {
        this.config.firstDayOfWeek.value = firstDayOfWeek;
    }
    getMonthWithTrailingAndLeadingDays(year, month) {
        if (year === 0)
            throw new NoYearZeroError();
        const firstDateOfMonth = new Date(year, month, 1);
        const monthWithDates = [this.getWeekFor(firstDateOfMonth)];
        let isInMonth = true;
        let first = monthWithDates[0][0]; // first day of first week of month
        while (isInMonth) {
            const newFirstDayOfWeek = new Date(first.getFullYear(), first.getMonth(), first.getDate() + 7);
            if (newFirstDayOfWeek.getMonth() === month) {
                monthWithDates.push(this.getWeekFor(newFirstDayOfWeek));
                first = newFirstDayOfWeek;
            }
            else {
                isInMonth = false;
            }
        }
        return monthWithDates;
    }
    getWeekFor(date) {
        const week = [this.getFirstDateOfWeek(date)];
        while (week.length < 7) {
            const lastDateOfWeek = week[week.length - 1];
            const nextDateOfWeek = new Date(lastDateOfWeek);
            nextDateOfWeek.setDate(lastDateOfWeek.getDate() + 1);
            week.push(nextDateOfWeek);
        }
        return week;
    }
    getMonthsFor(year) {
        return Object.values(Month)
            .filter((month) => !isNaN(Number(month)))
            .map((month) => new ExtendedDateImpl(year, Number(month), 1));
    }
    getFirstDateOfWeek(date) {
        const dateIsNthDayOfWeek = date.getDay() - this.firstDayOfWeek;
        const firstDateOfWeek = date;
        if (dateIsNthDayOfWeek === 0) {
            return firstDateOfWeek;
        }
        else if (dateIsNthDayOfWeek > 0) {
            firstDateOfWeek.setDate(date.getDate() - dateIsNthDayOfWeek);
        }
        else {
            firstDateOfWeek.setDate(date.getDate() - (7 + dateIsNthDayOfWeek));
        }
        return firstDateOfWeek;
    }
}

class TimeUnitsBuilder {
    constructor() {
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    build() {
        return new TimeUnitsImpl(this.config);
    }
    withConfig(config) {
        this.config = config;
        return this;
    }
}

var DateFormatDelimiter;
(function (DateFormatDelimiter) {
    DateFormatDelimiter["SLASH"] = "/";
    DateFormatDelimiter["DASH"] = "-";
    DateFormatDelimiter["PERIOD"] = ".";
})(DateFormatDelimiter || (DateFormatDelimiter = {}));
var DateFormatOrder;
(function (DateFormatOrder) {
    DateFormatOrder["DMY"] = "DMY";
    DateFormatOrder["MDY"] = "MDY";
    DateFormatOrder["YMD"] = "YMD";
})(DateFormatOrder || (DateFormatOrder = {}));

const formatRules = {
    slashMDY: {
        delimiter: DateFormatDelimiter.SLASH,
        order: DateFormatOrder.MDY,
    },
    slashDMY: {
        delimiter: DateFormatDelimiter.SLASH,
        order: DateFormatOrder.DMY,
    },
    slashYMD: {
        delimiter: DateFormatDelimiter.SLASH,
        order: DateFormatOrder.YMD,
    },
    periodDMY: {
        delimiter: DateFormatDelimiter.PERIOD,
        order: DateFormatOrder.DMY,
    },
    dashYMD: {
        delimiter: DateFormatDelimiter.DASH,
        order: DateFormatOrder.YMD,
    },
    dashDMY: {
        delimiter: DateFormatDelimiter.DASH,
        order: DateFormatOrder.DMY,
    },
};
const dateFormatLocalizedRules = new Map([
    ['ca-ES', formatRules.slashDMY],
    ['cs-CZ', formatRules.periodDMY],
    ['da-DK', formatRules.periodDMY],
    ['de-DE', formatRules.periodDMY],
    ['en-GB', formatRules.slashDMY],
    ['en-US', formatRules.slashMDY],
    ['es-ES', formatRules.slashDMY],
    ['et-EE', formatRules.periodDMY],
    ['fi-FI', formatRules.periodDMY],
    ['fr-FR', formatRules.slashDMY],
    ['hr-HR', formatRules.periodDMY],
    ['id-ID', formatRules.slashDMY],
    ['it-IT', formatRules.slashDMY],
    ['ja-JP', formatRules.slashYMD],
    ['ko-KR', formatRules.slashYMD],
    ['ky-KG', formatRules.slashDMY],
    ['lt-LT', formatRules.dashYMD],
    ['mk-MK', formatRules.periodDMY],
    ['nl-NL', formatRules.dashDMY],
    ['pl-PL', formatRules.periodDMY],
    ['pt-BR', formatRules.slashDMY],
    ['ro-RO', formatRules.periodDMY],
    ['ru-RU', formatRules.periodDMY],
    ['sk-SK', formatRules.periodDMY],
    ['sl-SI', formatRules.periodDMY],
    ['sr-Latn-RS', formatRules.periodDMY],
    ['sr-RS', formatRules.periodDMY],
    ['sv-SE', formatRules.dashYMD],
    ['tr-TR', formatRules.periodDMY],
    ['uk-UA', formatRules.periodDMY],
    ['zh-CN', formatRules.slashYMD],
    ['zh-TW', formatRules.slashYMD],
]);

class LocaleNotSupportedError extends Error {
    constructor(locale) {
        super(`Locale not supported: ${locale}`);
    }
}

class InvalidDateFormatError extends Error {
    constructor(dateFormat, locale) {
        super(`Invalid date format: ${dateFormat} for locale: ${locale}`);
    }
}

const _getMatchesOrThrow = (format, matcher, locale) => {
    const matches = format.match(matcher);
    if (!matches)
        throw new InvalidDateFormatError(format, locale);
    return matches;
};
const toDateString = (format, locale) => {
    const internationalFormat = /^\d{4}-\d{2}-\d{2}$/;
    if (internationalFormat.test(format))
        return format; // allow international format regardless of locale
    const localeDateFormatRule = dateFormatLocalizedRules.get(locale);
    if (!localeDateFormatRule)
        throw new LocaleNotSupportedError(locale);
    const { order, delimiter } = localeDateFormatRule;
    const pattern224Slashed = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/;
    const pattern224Dotted = /^(\d{1,2})\.(\d{1,2})\.(\d{4})$/;
    const pattern442Slashed = /^(\d{4})\/(\d{1,2})\/(\d{1,2})$/;
    if (order === DateFormatOrder.DMY && delimiter === DateFormatDelimiter.SLASH) {
        const matches = _getMatchesOrThrow(format, pattern224Slashed, locale);
        const [, day, month, year] = matches;
        return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
    }
    if (order === DateFormatOrder.MDY && delimiter === DateFormatDelimiter.SLASH) {
        const matches = _getMatchesOrThrow(format, pattern224Slashed, locale);
        const [, month, day, year] = matches;
        return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
    }
    if (order === DateFormatOrder.YMD && delimiter === DateFormatDelimiter.SLASH) {
        const matches = _getMatchesOrThrow(format, pattern442Slashed, locale);
        const [, year, month, day] = matches;
        return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
    }
    if (order === DateFormatOrder.DMY && delimiter === DateFormatDelimiter.PERIOD) {
        const matches = _getMatchesOrThrow(format, pattern224Dotted, locale);
        const [, day, month, year] = matches;
        return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
    }
    throw new InvalidDateFormatError(format, locale);
};

const createDatePickerState = (config, selectedDateParam) => {
    var _a;
    const currentDayDateString = toDateString$1(new Date());
    const initialSelectedDate = typeof selectedDateParam === 'string'
        ? selectedDateParam
        : currentDayDateString;
    const isOpen = signals.signal(false);
    const isDisabled = signals.signal(config.disabled || false);
    const datePickerView = signals.signal(DatePickerView.MONTH_DAYS);
    const selectedDate = signals.signal(initialSelectedDate);
    const datePickerDate = signals.signal(initialSelectedDate || currentDayDateString);
    const isDark = signals.signal(((_a = config.style) === null || _a === void 0 ? void 0 : _a.dark) || false);
    const inputDisplayedValue = signals.signal(selectedDateParam
        ? toLocalizedDateString(toJSDate(selectedDateParam), config.locale.value)
        : '');
    const lastValidDisplayedValue = signals.signal(inputDisplayedValue.value);
    signals.effect(() => {
        try {
            const newValue = toDateString(inputDisplayedValue.value, config.locale.value);
            if (newValue < config.min || newValue > config.max) {
                inputDisplayedValue.value = lastValidDisplayedValue.value;
                return;
            }
            selectedDate.value = newValue;
            datePickerDate.value = newValue;
            lastValidDisplayedValue.value = inputDisplayedValue.value;
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
        }
        catch (_e) {
            // Nothing to do here. We don't want to log errors when users are typing invalid formats
        }
    });
    let wasInitialized = false;
    const handleOnChange = (selectedDate) => {
        if (!wasInitialized)
            return (wasInitialized = true);
        config.listeners.onChange(selectedDate);
    };
    signals.effect(() => {
        var _a;
        if ((_a = config.listeners) === null || _a === void 0 ? void 0 : _a.onChange)
            handleOnChange(selectedDate.value);
    });
    return {
        inputWrapperElement: signals.signal(undefined),
        isOpen,
        isDisabled,
        datePickerView,
        selectedDate,
        datePickerDate,
        inputDisplayedValue,
        isDark,
        open: () => (isOpen.value = true),
        close: () => (isOpen.value = false),
        toggle: () => (isOpen.value = !isOpen.value),
        setView: (view) => (datePickerView.value = view),
    };
};

class DatePickerAppSingletonImpl {
    constructor(datePickerState, config, timeUnitsImpl, translate) {
        Object.defineProperty(this, "datePickerState", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: datePickerState
        });
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: config
        });
        Object.defineProperty(this, "timeUnitsImpl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: timeUnitsImpl
        });
        Object.defineProperty(this, "translate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: translate
        });
    }
}

class DatePickerAppSingletonBuilder {
    constructor() {
        Object.defineProperty(this, "datePickerState", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "timeUnitsImpl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "translate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    build() {
        return new DatePickerAppSingletonImpl(this.datePickerState, this.config, this.timeUnitsImpl, this.translate);
    }
    withDatePickerState(datePickerState) {
        this.datePickerState = datePickerState;
        return this;
    }
    withConfig(config) {
        this.config = config;
        return this;
    }
    withTimeUnitsImpl(timeUnitsImpl) {
        this.timeUnitsImpl = timeUnitsImpl;
        return this;
    }
    withTranslate(translate) {
        this.translate = translate;
        return this;
    }
}

var Placement;
(function (Placement) {
    Placement["TOP_START"] = "top-start";
    Placement["TOP_END"] = "top-end";
    Placement["BOTTOM_START"] = "bottom-start";
    Placement["BOTTOM_END"] = "bottom-end";
})(Placement || (Placement = {}));

class ConfigImpl {
    constructor(locale = DEFAULT_LOCALE, firstDayOfWeek = DEFAULT_FIRST_DAY_OF_WEEK, min = toDateString$1(new Date(1970, 0, 1)), max = toDateString$1(new Date(new Date().getFullYear() + 50, 11, 31)), placement = Placement.BOTTOM_START, listeners = {}, style = {}, teleportTo, label, name, disabled) {
        Object.defineProperty(this, "min", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: min
        });
        Object.defineProperty(this, "max", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: max
        });
        Object.defineProperty(this, "placement", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: placement
        });
        Object.defineProperty(this, "listeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: listeners
        });
        Object.defineProperty(this, "style", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: style
        });
        Object.defineProperty(this, "teleportTo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: teleportTo
        });
        Object.defineProperty(this, "label", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: label
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "disabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: disabled
        });
        Object.defineProperty(this, "locale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "firstDayOfWeek", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.locale = signals.signal(locale);
        this.firstDayOfWeek = signals.signal(firstDayOfWeek);
    }
}

class ConfigBuilder {
    constructor() {
        Object.defineProperty(this, "locale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "firstDayOfWeek", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "min", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "max", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "placement", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "listeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "style", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "teleportTo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "label", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "disabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    build() {
        return new ConfigImpl(this.locale, this.firstDayOfWeek, this.min, this.max, this.placement, this.listeners, this.style, this.teleportTo, this.label, this.name, this.disabled);
    }
    withLocale(locale) {
        this.locale = locale;
        return this;
    }
    withFirstDayOfWeek(firstDayOfWeek) {
        this.firstDayOfWeek = firstDayOfWeek;
        return this;
    }
    withMin(min) {
        this.min = min;
        return this;
    }
    withMax(max) {
        this.max = max;
        return this;
    }
    withPlacement(placement) {
        this.placement = placement;
        return this;
    }
    withListeners(listeners) {
        this.listeners = listeners;
        return this;
    }
    withStyle(style) {
        this.style = style;
        return this;
    }
    withTeleportTo(teleportTo) {
        this.teleportTo = teleportTo;
        return this;
    }
    withLabel(label) {
        this.label = label;
        return this;
    }
    withName(name) {
        this.name = name;
        return this;
    }
    withDisabled(disabled) {
        this.disabled = disabled;
        return this;
    }
}

const datePickerDeDE = {
    Date: 'Datum',
    'MM/DD/YYYY': 'TT.MM.JJJJ',
    'Next month': 'Nächster Monat',
    'Previous month': 'Vorheriger Monat',
    'Choose Date': 'Datum auswählen',
};

const calendarDeDE = {
    Today: 'Heute',
    Month: 'Monat',
    Week: 'Woche',
    Day: 'Tag',
    'Select View': 'Ansicht auswählen',
    events: 'Ereignisse',
    event: 'Ereignis',
    'No events': 'Keine Ereignisse',
    'Next period': 'Nächster Zeitraum',
    'Previous period': 'Vorheriger Zeitraum',
    to: 'bis', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Ganztägige und mehrtägige Ereignisse',
    'Link to {{n}} more events on {{date}}': 'Link zu {{n}} weiteren Ereignissen am {{date}}',
    'Link to 1 more event on {{date}}': 'Link zu 1 weiteren Ereignis am {{date}}',
    CW: 'KW {{week}}',
};

const timePickerDeDE = {
    Time: 'Uhrzeit',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Abbrechen',
    OK: 'OK',
    'Select time': 'Uhrzeit auswählen',
};

const deDE = {
    ...datePickerDeDE,
    ...calendarDeDE,
    ...timePickerDeDE,
};

const datePickerEnUS = {
    Date: 'Date',
    'MM/DD/YYYY': 'MM/DD/YYYY',
    'Next month': 'Next month',
    'Previous month': 'Previous month',
    'Choose Date': 'Choose Date',
};

const calendarEnUS = {
    Today: 'Today',
    Month: 'Month',
    Week: 'Week',
    Day: 'Day',
    'Select View': 'Select View',
    events: 'events',
    event: 'event',
    'No events': 'No events',
    'Next period': 'Next period',
    'Previous period': 'Previous period',
    to: 'to', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Full day- and multiple day events',
    'Link to {{n}} more events on {{date}}': 'Link to {{n}} more events on {{date}}',
    'Link to 1 more event on {{date}}': 'Link to 1 more event on {{date}}',
    CW: 'Week {{week}}',
};

const timePickerEnUS = {
    Time: 'Time',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Cancel',
    OK: 'OK',
    'Select time': 'Select time',
};

const enUS = {
    ...datePickerEnUS,
    ...calendarEnUS,
    ...timePickerEnUS,
};

const datePickerItIT = {
    Date: 'Data',
    'MM/DD/YYYY': 'DD/MM/YYYY',
    'Next month': 'Mese successivo',
    'Previous month': 'Mese precedente',
    'Choose Date': 'Scegli la data',
};

const calendarItIT = {
    Today: 'Oggi',
    Month: 'Mese',
    Week: 'Settimana',
    Day: 'Giorno',
    'Select View': 'Seleziona la vista',
    events: 'eventi',
    event: 'evento',
    'No events': 'Nessun evento',
    'Next period': 'Periodo successivo',
    'Previous period': 'Periodo precedente',
    to: 'a', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Eventi della giornata e plurigiornalieri',
    'Link to {{n}} more events on {{date}}': 'Link a {{n}} eventi in più il {{date}}',
    'Link to 1 more event on {{date}}': 'Link a 1 evento in più il {{date}}',
    CW: 'Settimana {{week}}',
};

const timePickerItIT = {
    Time: 'Ora',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Annulla',
    OK: 'OK',
    'Select time': 'Seleziona ora',
};

const itIT = {
    ...datePickerItIT,
    ...calendarItIT,
    ...timePickerItIT,
};

const datePickerEnGB = {
    Date: 'Date',
    'MM/DD/YYYY': 'DD/MM/YYYY',
    'Next month': 'Next month',
    'Previous month': 'Previous month',
    'Choose Date': 'Choose Date',
};

const calendarEnGB = {
    Today: 'Today',
    Month: 'Month',
    Week: 'Week',
    Day: 'Day',
    'Select View': 'Select View',
    events: 'events',
    event: 'event',
    'No events': 'No events',
    'Next period': 'Next period',
    'Previous period': 'Previous period',
    to: 'to', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Full day- and multiple day events',
    'Link to {{n}} more events on {{date}}': 'Link to {{n}} more events on {{date}}',
    'Link to 1 more event on {{date}}': 'Link to 1 more event on {{date}}',
    CW: 'Week {{week}}',
};

const timePickerEnGB = {
    Time: 'Time',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Cancel',
    OK: 'OK',
    'Select time': 'Select time',
};

const enGB = {
    ...datePickerEnGB,
    ...calendarEnGB,
    ...timePickerEnGB,
};

const datePickerSvSE = {
    Date: 'Datum',
    'MM/DD/YYYY': 'ÅÅÅÅ-MM-DD',
    'Next month': 'Nästa månad',
    'Previous month': 'Föregående månad',
    'Choose Date': 'Välj datum',
};

const calendarSvSE = {
    Today: 'Idag',
    Month: 'Månad',
    Week: 'Vecka',
    Day: 'Dag',
    'Select View': 'Välj vy',
    events: 'händelser',
    event: 'händelse',
    'No events': 'Inga händelser',
    'Next period': 'Nästa period',
    'Previous period': 'Föregående period',
    to: 'till', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Heldags- och flerdagshändelser',
    'Link to {{n}} more events on {{date}}': 'Länk till {{n}} fler händelser den {{date}}',
    'Link to 1 more event on {{date}}': 'Länk till 1 händelse till den {{date}}',
    CW: 'Vecka {{week}}',
};

const timePickerSvSE = {
    Time: 'Tid',
    AM: 'FM',
    PM: 'EM',
    Cancel: 'Avbryt',
    OK: 'OK',
    'Select time': 'Välj tid',
};

const svSE = {
    ...datePickerSvSE,
    ...calendarSvSE,
    ...timePickerSvSE,
};

const datePickerZhCN = {
    Date: '日期',
    'MM/DD/YYYY': '年/月/日',
    'Next month': '下个月',
    'Previous month': '上个月',
    'Choose Date': '选择日期',
};

const calendarZhCN = {
    Today: '今天',
    Month: '月',
    Week: '周',
    Day: '日',
    'Select View': '选择视图',
    events: '场活动',
    event: '活动',
    'No events': '没有活动',
    'Next period': '下一段时间',
    'Previous period': '上一段时间',
    to: '至', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': '全天和多天活动',
    'Link to {{n}} more events on {{date}}': '链接到{{date}}上的{{n}}个更多活动',
    'Link to 1 more event on {{date}}': '链接到{{date}}上的1个更多活动',
    CW: '第{{week}}周',
};

const timePickerZhCN = {
    Time: '时间',
    AM: '上午',
    PM: '下午',
    Cancel: '取消',
    OK: '确定',
    'Select time': '选择时间',
};

const zhCN = {
    ...datePickerZhCN,
    ...calendarZhCN,
    ...timePickerZhCN,
};

const datePickerZhTW = {
    Date: '日期',
    'MM/DD/YYYY': '年/月/日',
    'Next month': '下個月',
    'Previous month': '上個月',
    'Choose Date': '選擇日期',
};

const calendarZhTW = {
    Today: '今天',
    Month: '月',
    Week: '周',
    Day: '日',
    'Select View': '選擇檢視模式',
    events: '場活動',
    event: '活動',
    'No events': '沒有活動',
    'Next period': '下一段時間',
    'Previous period': '上一段時間',
    to: '到', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': '全天和多天活動',
    'Link to {{n}} more events on {{date}}': '連接到{{date}}上的{{n}}個更多活動',
    'Link to 1 more event on {{date}}': '連接到{{date}}上的1個更多活動',
    CW: '第{{week}}周',
};

const timePickerZhTW = {
    Time: '時間',
    AM: '上午',
    PM: '下午',
    Cancel: '取消',
    OK: '確定',
    'Select time': '選擇時間',
};

const zhTW = {
    ...datePickerZhTW,
    ...calendarZhTW,
    ...timePickerZhTW,
};

const datePickerJaJP = {
    Date: '日付',
    'MM/DD/YYYY': '年/月/日',
    'Next month': '次の月',
    'Previous month': '前の月',
    'Choose Date': '日付を選択',
};

const calendarJaJP = {
    Today: '今日',
    Month: '月',
    Week: '週',
    Day: '日',
    'Select View': 'ビューを選択',
    events: 'イベント',
    event: 'イベント',
    'No events': 'イベントなし',
    'Next period': '次の期間',
    'Previous period': '前の期間',
    to: 'から', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': '終日および複数日イベント',
    'Link to {{n}} more events on {{date}}': '{{date}} に{{n}}件のイベントへのリンク',
    'Link to 1 more event on {{date}}': '{{date}} に1件のイベントへのリンク',
    CW: '週 {{week}}',
};

const timePickerJaJP = {
    Time: '時間',
    AM: '午前',
    PM: '午後',
    Cancel: 'キャンセル',
    OK: 'OK',
    'Select time': '時間を選択',
};

const jaJP = {
    ...datePickerJaJP,
    ...calendarJaJP,
    ...timePickerJaJP,
};

const datePickerRuRU = {
    Date: 'Дата',
    'MM/DD/YYYY': 'ММ/ДД/ГГГГ',
    'Next month': 'Следующий месяц',
    'Previous month': 'Прошлый месяц',
    'Choose Date': 'Выберите дату',
};

const calendarRuRU = {
    Today: 'Сегодня',
    Month: 'Месяц',
    Week: 'Неделя',
    Day: 'День',
    'Select View': 'Выберите вид',
    events: 'события',
    event: 'событие',
    'No events': 'Нет событий',
    'Next period': 'Следующий период',
    'Previous period': 'Прошлый период',
    to: 'по', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'События на целый день и несколько дней подряд',
    'Link to {{n}} more events on {{date}}': 'Ссылка на {{n}} дополнительных событий на {{date}}',
    'Link to 1 more event on {{date}}': 'Ссылка на 1 дополнительное событие на {{date}}',
    CW: 'Неделя {{week}}',
};

const timePickerRuRU = {
    Time: 'Время',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Отмена',
    OK: 'ОК',
    'Select time': 'Выберите время',
};

const ruRU = {
    ...datePickerRuRU,
    ...calendarRuRU,
    ...timePickerRuRU,
};

const datePickerKoKR = {
    Date: '일자',
    'MM/DD/YYYY': '년/월/일',
    'Next month': '다음 달',
    'Previous month': '이전 달',
    'Choose Date': '날짜 선택',
};

const calendarKoKR = {
    Today: '오늘',
    Month: '월',
    Week: '주',
    Day: '일',
    'Select View': '보기 선택',
    events: '일정들',
    event: '일정',
    'No events': '일정 없음',
    'Next period': '다음',
    'Previous period': '이전',
    to: '부터', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': '종일 및 복수일 일정',
    'Link to {{n}} more events on {{date}}': '{{date}}에 {{n}}개 이상의 이벤트로 이동',
    'Link to 1 more event on {{date}}': '{{date}}에 1개 이상의 이벤트로 이동',
    CW: '{{week}}주',
};

const timePickerKoKR = {
    Time: '시간',
    AM: '오전',
    PM: '오후',
    Cancel: '취소',
    OK: '확인',
    'Select time': '시간 선택',
};

const koKR = {
    ...datePickerKoKR,
    ...calendarKoKR,
    ...timePickerKoKR,
};

const datePickerFrFR = {
    Date: 'Date',
    'MM/DD/YYYY': 'JJ/MM/AAAA',
    'Next month': 'Mois suivant',
    'Previous month': 'Mois précédent',
    'Choose Date': 'Choisir une date',
};

const calendarFrFR = {
    Today: "Aujourd'hui",
    Month: 'Mois',
    Week: 'Semaine',
    Day: 'Jour',
    'Select View': 'Choisir la vue',
    events: 'événements',
    event: 'événement',
    'No events': 'Aucun événement',
    'Next period': 'Période suivante',
    'Previous period': 'Période précédente',
    to: 'à', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': "Événements d'une ou plusieurs journées",
    'Link to {{n}} more events on {{date}}': 'Lien vers {{n}} autres événements le {{date}}',
    'Link to 1 more event on {{date}}': 'Lien vers 1 autre événement le {{date}}',
    CW: 'Semaine {{week}}',
};

const timePickerFrFR = {
    Time: 'Heure',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Annuler',
    OK: 'OK',
    'Select time': "Sélectionner l'heure",
};

const frFR = {
    ...datePickerFrFR,
    ...calendarFrFR,
    ...timePickerFrFR,
};

const datePickerDaDK = {
    Date: 'Dato',
    'MM/DD/YYYY': 'ÅÅÅÅ-MM-DD',
    'Next month': 'Næste måned',
    'Previous month': 'Foregående måned',
    'Choose Date': 'Vælg dato',
};

const calendarDaDK = {
    Today: 'I dag',
    Month: 'Måned',
    Week: 'Uge',
    Day: 'Dag',
    'Select View': 'Vælg visning',
    events: 'begivenheder',
    event: 'begivenhed',
    'No events': 'Ingen begivenheder',
    'Next period': 'Næste periode',
    'Previous period': 'Forgående periode',
    to: 'til', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Heldagsbegivenheder og flerdagsbegivenheder',
    'Link to {{n}} more events on {{date}}': 'Link til {{n}} flere begivenheder den {{date}}',
    'Link to 1 more event on {{date}}': 'Link til 1 mere begivenhed den {{date}}',
    CW: 'Uge {{week}}',
};

const timePickerDaDK = {
    Time: 'Tid',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Annuller',
    OK: 'OK',
    'Select time': 'Vælg tid',
};

const daDK = {
    ...datePickerDaDK,
    ...calendarDaDK,
    ...timePickerDaDK,
};

const datePickerPlPL = {
    Date: 'Data',
    'MM/DD/YYYY': 'DD/MM/YYYY',
    'Next month': 'Następny miesiąc',
    'Previous month': 'Poprzedni miesiąc',
    'Choose Date': 'Wybiewrz datę',
};

const calendarPlPL = {
    Today: 'Dzisiaj',
    Month: 'Miesiąc',
    Week: 'Tydzień',
    Day: 'Dzień',
    'Select View': 'Wybierz widok',
    events: 'wydarzenia',
    event: 'wydarzenie',
    'No events': 'Brak wydarzeń',
    'Next period': 'Następny okres',
    'Previous period': 'Poprzedni okres',
    to: 'do', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Wydarzenia całodniowe i wielodniowe',
    'Link to {{n}} more events on {{date}}': 'Link do {{n}} kolejnych wydarzeń w dniu {{date}}',
    'Link to 1 more event on {{date}}': 'Link do 1 kolejnego wydarzenia w dniu {{date}}',
    CW: 'Tydzień {{week}}',
};

const timePickerPlPL = {
    Time: 'Godzina',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Anuluj',
    OK: 'OK',
    'Select time': 'Wybierz godzinę',
};

const plPL = {
    ...datePickerPlPL,
    ...calendarPlPL,
    ...timePickerPlPL,
};

const datePickerEsES = {
    Date: 'Fecha',
    'MM/DD/YYYY': 'DD/MM/YYYY',
    'Next month': 'Siguiente mes',
    'Previous month': 'Mes anterior',
    'Choose Date': 'Seleccione una fecha',
};

const calendarEsES = {
    Today: 'Hoy',
    Month: 'Mes',
    Week: 'Semana',
    Day: 'Día',
    'Select View': 'Seleccione una vista',
    events: 'eventos',
    event: 'evento',
    'No events': 'Sin eventos',
    'Next period': 'Siguiente período',
    'Previous period': 'Período anterior',
    to: 'a', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Día completo y eventos de múltiples días',
    'Link to {{n}} more events on {{date}}': 'Enlace a {{n}} eventos más el {{date}}',
    'Link to 1 more event on {{date}}': 'Enlace a 1 evento más el {{date}}',
    CW: 'Semana {{week}}',
};

const timePickerEsES = {
    Time: 'Hora',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Cancelar',
    OK: 'Aceptar',
    'Select time': 'Seleccionar hora',
};

const esES = {
    ...datePickerEsES,
    ...calendarEsES,
    ...timePickerEsES,
};

const calendarNlNL = {
    Today: 'Vandaag',
    Month: 'Maand',
    Week: 'Week',
    Day: 'Dag',
    'Select View': 'Kies weergave',
    events: 'gebeurtenissen',
    event: 'gebeurtenis',
    'No events': 'Geen gebeurtenissen',
    'Next period': 'Volgende periode',
    'Previous period': 'Vorige periode',
    to: 'tot', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Evenementen van een hele dag en meerdere dagen',
    'Link to {{n}} more events on {{date}}': 'Link naar {{n}} meer evenementen op {{date}}',
    'Link to 1 more event on {{date}}': 'Link naar 1 meer evenement op {{date}}',
    CW: 'Week {{week}}',
};

const datePickerNlNL = {
    Date: 'Datum',
    'MM/DD/YYYY': 'DD-MM-JJJJ',
    'Next month': 'Volgende maand',
    'Previous month': 'Vorige maand',
    'Choose Date': 'Kies datum',
};

const timePickerNlNL = {
    Time: 'Tijd',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Annuleren',
    OK: 'OK',
    'Select time': 'Selecteer tijd',
};

const nlNL = {
    ...datePickerNlNL,
    ...calendarNlNL,
    ...timePickerNlNL,
};

const datePickerPtBR = {
    Date: 'Data',
    'MM/DD/YYYY': 'DD/MM/YYYY',
    'Next month': 'Mês seguinte',
    'Previous month': 'Mês anterior',
    'Choose Date': 'Escolha uma data',
};

const calendarPtBR = {
    Today: 'Hoje',
    Month: 'Mês',
    Week: 'Semana',
    Day: 'Dia',
    'Select View': 'Selecione uma visualização',
    events: 'eventos',
    event: 'evento',
    'No events': 'Sem eventos',
    'Next period': 'Período seguinte',
    'Previous period': 'Período anterior',
    to: 'a', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Dia inteiro e eventos de vários dias',
    'Link to {{n}} more events on {{date}}': 'Link para mais {{n}} eventos em {{date}}',
    'Link to 1 more event on {{date}}': 'Link para mais 1 evento em {{date}}',
    CW: 'Semana {{week}}',
};

const timePickerPtBR = {
    Time: 'Hora',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Cancelar',
    OK: 'OK',
    'Select time': 'Selecionar hora',
};

const ptBR = {
    ...datePickerPtBR,
    ...calendarPtBR,
    ...timePickerPtBR,
};

const datePickerSkSK = {
    Date: 'Dátum',
    'MM/DD/YYYY': 'DD/MM/YYYY',
    'Next month': 'Ďalší mesiac',
    'Previous month': 'Predchádzajúci mesiac',
    'Choose Date': 'Vyberte dátum',
};

const calendarSkSK = {
    Today: 'Dnes',
    Month: 'Mesiac',
    Week: 'Týždeň',
    Day: 'Deň',
    'Select View': 'Vyberte zobrazenie',
    events: 'udalosti',
    event: 'udalosť',
    'No events': 'Žiadne udalosti',
    'Next period': 'Ďalšie obdobie',
    'Previous period': 'Predchádzajúce obdobie',
    to: 'do', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Celodenné a viacdňové udalosti',
    'Link to {{n}} more events on {{date}}': 'Odkaz na {{n}} ďalších udalostí dňa {{date}}',
    'Link to 1 more event on {{date}}': 'Odkaz na 1 ďalšiu udalosť dňa {{date}}',
    CW: '{{week}}. týždeň',
};

const timePickerSkSK = {
    Time: 'Čas',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Zrušiť',
    OK: 'OK',
    'Select time': 'Vybrať čas',
};

const skSK = {
    ...datePickerSkSK,
    ...calendarSkSK,
    ...timePickerSkSK,
};

const datePickerMkMK = {
    Date: 'Датум',
    'MM/DD/YYYY': 'DD/MM/YYYY',
    'Next month': 'Следен месец',
    'Previous month': 'Претходен месец',
    'Choose Date': 'Избери Датум',
};

const calendarMkMK = {
    Today: 'Денес',
    Month: 'Месец',
    Week: 'Недела',
    Day: 'Ден',
    'Select View': 'Избери Преглед',
    events: 'настани',
    event: 'настан',
    'No events': 'Нема настани',
    'Next period': 'Следен период',
    'Previous period': 'Претходен период',
    to: 'до', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Целодневни и повеќедневни настани',
    'Link to {{n}} more events on {{date}}': 'Линк до {{n}} повеќе настани на {{date}}',
    'Link to 1 more event on {{date}}': 'Линк до 1 повеќе настан на {{date}}',
    CW: 'Недела {{week}}',
};

const timePickerMkMK = {
    Time: 'Време',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Откажи',
    OK: 'У реду',
    'Select time': 'Избери време',
};

const mkMK = {
    ...datePickerMkMK,
    ...calendarMkMK,
    ...timePickerMkMK,
};

const datePickerTrTR = {
    Date: 'Tarih',
    'MM/DD/YYYY': 'GG/AA/YYYY',
    'Next month': 'Sonraki ay',
    'Previous month': 'Önceki ay',
    'Choose Date': 'Tarih Seç',
};

const calendarTrTR = {
    Today: 'Bugün',
    Month: 'Aylık',
    Week: 'Haftalık',
    Day: 'Günlük',
    'Select View': 'Görünüm Seç',
    events: 'etkinlikler',
    event: 'etkinlik',
    'No events': 'Etkinlik yok',
    'Next period': 'Sonraki dönem',
    'Previous period': 'Önceki dönem',
    to: 'dan', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Tüm gün ve çoklu gün etkinlikleri',
    'Link to {{n}} more events on {{date}}': '{{date}} tarihinde {{n}} etkinliğe bağlantı',
    'Link to 1 more event on {{date}}': '{{date}} tarihinde 1 etkinliğe bağlantı',
    CW: '{{week}}. Hafta',
};

const timePickerTrTR = {
    Time: 'Zaman',
    AM: 'ÖÖ',
    PM: 'ÖS',
    Cancel: 'İptal',
    OK: 'Tamam',
    'Select time': 'Zamanı seç',
};

const trTR = {
    ...datePickerTrTR,
    ...calendarTrTR,
    ...timePickerTrTR,
};

const datePickerKyKG = {
    Date: 'Датасы',
    'MM/DD/YYYY': 'АА/КК/ЖЖЖЖ',
    'Next month': 'Кийинки ай',
    'Previous month': 'Өткөн ай',
    'Choose Date': 'Күндү тандаңыз',
};

const calendarKyKG = {
    Today: 'Бүгүн',
    Month: 'Ай',
    Week: 'Апта',
    Day: 'Күн',
    'Select View': 'Көрүнүштү тандаңыз',
    events: 'Окуялар',
    event: 'Окуя',
    'No events': 'Окуя жок',
    'Next period': 'Кийинки мезгил',
    'Previous period': 'Өткөн мезгил',
    to: 'чейин', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Күн бою жана бир нече күн катары менен болгон окуялар',
    'Link to {{n}} more events on {{date}}': '{{date}} күнүндө {{n}} окуяга байланыш',
    'Link to 1 more event on {{date}}': '{{date}} күнүндө 1 окуяга байланыш',
    CW: 'Апта {{week}}',
};

const timePickerKyKG = {
    Time: 'Убакты',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Болбой',
    OK: 'Ооба',
    'Select time': 'Убакты тандаңыз',
};

const kyKG = {
    ...datePickerKyKG,
    ...calendarKyKG,
    ...timePickerKyKG,
};

const datePickerIdID = {
    Date: 'Tanggal',
    'MM/DD/YYYY': 'DD.MM.YYYY',
    'Next month': 'Bulan depan',
    'Previous month': 'Bulan sebelumnya',
    'Choose Date': 'Pilih tanggal',
};

const calendarIdID = {
    Today: 'Hari Ini',
    Month: 'Bulan',
    Week: 'Minggu',
    Day: 'Hari',
    'Select View': 'Pilih tampilan',
    events: 'Acara',
    event: 'Acara',
    'No events': 'Tidak ada acara',
    'Next period': 'Periode selanjutnya',
    'Previous period': 'Periode sebelumnya',
    to: 'sampai', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Sepanjang hari dan acara beberapa hari ',
    'Link to {{n}} more events on {{date}}': 'Tautan ke {{n}} acara lainnya pada {{date}}',
    'Link to 1 more event on {{date}}': 'Tautan ke 1 acara lainnya pada {{date}}',
    CW: 'Minggu {{week}}',
};

const timePickerIdID = {
    Time: 'Waktu',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Batalkan',
    OK: 'OK',
    'Select time': 'Pilih waktu',
};

const idID = {
    ...datePickerIdID,
    ...calendarIdID,
    ...timePickerIdID,
};

const datePickerCsCZ = {
    Date: 'Datum',
    'MM/DD/YYYY': 'DD/MM/YYYY',
    'Next month': 'Další měsíc',
    'Previous month': 'Předchozí měsíc',
    'Choose Date': 'Vyberte datum',
};

const calendarCsCZ = {
    Today: 'Dnes',
    Month: 'Měsíc',
    Week: 'Týden',
    Day: 'Den',
    'Select View': 'Vyberte zobrazení',
    events: 'události',
    event: 'událost',
    'No events': 'Žádné události',
    'Next period': 'Příští období',
    'Previous period': 'Předchozí období',
    to: 'do', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Celodenní a vícedenní události',
    'Link to {{n}} more events on {{date}}': 'Odkaz na {{n}} dalších událostí dne {{date}}',
    'Link to 1 more event on {{date}}': 'Odkaz na 1 další událost dne {{date}}',
    CW: 'Týden {{week}}',
};

const timePickerCsCZ = {
    Time: 'Čas',
    AM: 'Dopoledne',
    PM: 'Odpoledne',
    Cancel: 'Zrušit',
    OK: 'OK',
    'Select time': 'Vyberte čas',
};

const csCZ = {
    ...datePickerCsCZ,
    ...calendarCsCZ,
    ...timePickerCsCZ,
};

const datePickerEtEE = {
    Date: 'Kuupäev',
    'MM/DD/YYYY': 'PP.KK.AAAA',
    'Next month': 'Järgmine kuu',
    'Previous month': 'Eelmine kuu',
    'Choose Date': 'Vali kuupäev',
};

const calendarEtEE = {
    Today: 'Täna',
    Month: 'Kuu',
    Week: 'Nädal',
    Day: 'Päev',
    'Select View': 'Vali vaade',
    events: 'sündmused',
    event: 'sündmus',
    'No events': 'Pole sündmusi',
    'Next period': 'Järgmine periood',
    'Previous period': 'Eelmine periood',
    to: 'kuni',
    'Full day- and multiple day events': 'Täispäeva- ja mitmepäevasündmused',
    'Link to {{n}} more events on {{date}}': 'Link {{n}} rohkematele sündmustele kuupäeval {{date}}',
    'Link to 1 more event on {{date}}': 'Link ühele lisasündmusele kuupäeval {{date}}',
    CW: 'Nädala number {{week}}',
};

const timePickerEtEE = {
    Time: 'Aeg',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Loobu',
    OK: 'OK',
    'Select time': 'Vali aeg',
};

const etEE = {
    ...datePickerEtEE,
    ...calendarEtEE,
    ...timePickerEtEE,
};

const datePickerUkUA = {
    Date: 'Дата',
    'MM/DD/YYYY': 'ММ/ДД/РРРР',
    'Next month': 'Наступний місяць',
    'Previous month': 'Минулий місяць',
    'Choose Date': 'Виберіть дату',
};

const calendarUkUA = {
    Today: 'Сьогодні',
    Month: 'Місяць',
    Week: 'Тиждень',
    Day: 'День',
    'Select View': 'Виберіть вигляд',
    events: 'події',
    event: 'подія',
    'No events': 'Немає подій',
    'Next period': 'Наступний період',
    'Previous period': 'Минулий період',
    to: 'по', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Події на цілий день і кілька днів поспіль',
    'Link to {{n}} more events on {{date}}': 'Посилання на {{n}} додаткові події на {{date}}',
    'Link to 1 more event on {{date}}': 'Посилання на 1 додаткову подію на {{date}}',
    CW: 'Тиждень {{week}}',
};

const timePickerUkUA = {
    Time: 'Час',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Скасувати',
    OK: 'Гаразд',
    'Select time': 'Виберіть час',
};

const ukUA = {
    ...datePickerUkUA,
    ...calendarUkUA,
    ...timePickerUkUA,
};

const datePickerSrLatnRS = {
    Date: 'Datum',
    'MM/DD/YYYY': 'DD/MM/YYYY',
    'Next month': 'Sledeći mesec',
    'Previous month': 'Prethodni mesec',
    'Choose Date': 'Izaberite datum',
};

const calendarSrLatnRS = {
    Today: 'Danas',
    Month: 'Mesec',
    Week: 'Nedelja',
    Day: 'Dan',
    'Select View': 'Odaberite pregled',
    events: 'Događaji',
    event: 'Događaj',
    'No events': 'Nema događaja',
    'Next period': 'Naredni period',
    'Previous period': 'Prethodni period',
    to: 'do', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Celodnevni i višednevni događaji',
    'Link to {{n}} more events on {{date}}': 'Link do još {{n}} događaja na {{date}}',
    'Link to 1 more event on {{date}}': 'Link do jednog događaja na {{date}}',
    CW: 'Nedelja {{week}}',
};

const timePickerSrLatnRS = {
    Time: 'Vrijeme',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Otkaži',
    OK: 'U redu',
    'Select time': 'Odaberi vrijeme',
};

const srLatnRS = {
    ...datePickerSrLatnRS,
    ...calendarSrLatnRS,
    ...timePickerSrLatnRS,
};

const datePickerCaES = {
    Date: 'Data',
    'MM/DD/YYYY': 'DD/MM/YYYY',
    'Next month': 'Següent mes',
    'Previous month': 'Mes anterior',
    'Choose Date': 'Selecciona una data',
};

const calendarCaES = {
    Today: 'Avui',
    Month: 'Mes',
    Week: 'Setmana',
    Day: 'Dia',
    'Select View': 'Selecciona una vista',
    events: 'Esdeveniments',
    event: 'Esdeveniment',
    'No events': 'Sense esdeveniments',
    'Next period': 'Següent període',
    'Previous period': 'Període anterior',
    to: 'a', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Esdeveniments de dia complet i de múltiples dies',
    'Link to {{n}} more events on {{date}}': 'Enllaç a {{n}} esdeveniments més el {{date}}',
    'Link to 1 more event on {{date}}': 'Enllaç a 1 esdeveniment més el {{date}}',
    CW: 'Setmana {{week}}',
};

const timePickerCaES = {
    Time: 'Hora',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Cancel·lar',
    OK: 'Acceptar',
    'Select time': 'Selecciona una hora',
};

const caES = {
    ...datePickerCaES,
    ...calendarCaES,
    ...timePickerCaES,
};

const datePickerSrRS = {
    Date: 'Датум',
    'MM/DD/YYYY': 'DD/MM/YYYY',
    'Next month': 'Следећи месец',
    'Previous month': 'Претходни месец',
    'Choose Date': 'Изаберите Датум',
};

const calendarSrRS = {
    Today: 'Данас',
    Month: 'Месец',
    Week: 'Недеља',
    Day: 'Дан',
    'Select View': 'Изаберите преглед',
    events: 'Догађаји',
    event: 'Догађај',
    'No events': 'Нема догађаја',
    'Next period': 'Следећи период',
    'Previous period': 'Претходни период',
    to: 'да', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Целодневни и вишедневни догађаји',
    'Link to {{n}} more events on {{date}}': 'Линк до још {{n}} догађаја на {{date}}',
    'Link to 1 more event on {{date}}': 'Линк до још 1 догађаја {{date}}',
    CW: 'Недеља {{week}}',
};

const timePickerSrRS = {
    Time: 'Време',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Откажи',
    OK: 'У реду',
    'Select time': 'Изабери време',
};

const srRS = {
    ...datePickerSrRS,
    ...calendarSrRS,
    ...timePickerSrRS,
};

const datePickerLtLT = {
    Date: 'Data',
    'MM/DD/YYYY': 'MMMM-MM-DD',
    'Next month': 'Kitas mėnuo',
    'Previous month': 'Ankstesnis mėnuo',
    'Choose Date': 'Pasirinkite datą',
};

const calendarLtLT = {
    Today: 'Šiandien',
    Month: 'Mėnuo',
    Week: 'Savaitė',
    Day: 'Diena',
    'Select View': 'Pasirinkite vaizdą',
    events: 'įvykiai',
    event: 'įvykis',
    'No events': 'Įvykių nėra',
    'Next period': 'Kitas laikotarpis',
    'Previous period': 'Ankstesnis laikotarpis',
    to: 'iki', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Visos dienos ir kelių dienų įvykiai',
    'Link to {{n}} more events on {{date}}': 'Nuoroda į dar {{n}} įvykius {{date}}',
    'Link to 1 more event on {{date}}': 'Nuoroda į dar 1 vieną įvykį {{date}}',
    CW: '{{week}} savaitė',
};

const timePickerLtLT = {
    Time: 'Laikas',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Atšaukti',
    OK: 'Gerai',
    'Select time': 'Pasirinkite laiką',
};

const ltLT = {
    ...datePickerLtLT,
    ...calendarLtLT,
    ...timePickerLtLT,
};

const datePickerHrHR = {
    Date: 'Datum',
    'MM/DD/YYYY': 'DD/MM/YYYY',
    'Next month': 'Sljedeći mjesec',
    'Previous month': 'Prethodni mjesec',
    'Choose Date': 'Izaberite datum',
};

const calendarHrHR = {
    Today: 'Danas',
    Month: 'Mjesec',
    Week: 'Nedjelja',
    Day: 'Dan',
    'Select View': 'Odaberite pregled',
    events: 'Događaji',
    event: 'Događaj',
    'No events': 'Nema događaja',
    'Next period': 'Sljedeći period',
    'Previous period': 'Prethodni period',
    to: 'do', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Cjelodnevni i višednevni događaji',
    'Link to {{n}} more events on {{date}}': 'Link do još {{n}} događaja na {{date}}',
    'Link to 1 more event on {{date}}': 'Link do još jednog događaja na {{date}}',
    CW: '{{week}}. tjedan',
};

const timePickerHrHR = {
    Time: 'Vrijeme',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Otkaži',
    OK: 'U redu',
    'Select time': 'Odaberi vrijeme',
};

const hrHR = {
    ...datePickerHrHR,
    ...calendarHrHR,
    ...timePickerHrHR,
};

const datePickerSlSI = {
    Date: 'Datum',
    'MM/DD/YYYY': 'MM.DD.YYYY',
    'Next month': 'Naslednji mesec',
    'Previous month': 'Prejšnji mesec',
    'Choose Date': 'Izberi datum',
};

const calendarSlSI = {
    Today: 'Danes',
    Month: 'Mesec',
    Week: 'Teden',
    Day: 'Dan',
    'Select View': 'Izberi pogled',
    events: 'dogodki',
    event: 'dogodek',
    'No events': 'Ni dogodkov',
    'Next period': 'Naslednji dogodek',
    'Previous period': 'Prejšnji dogodek',
    to: 'do', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Celodnevni in večdnevni dogodki',
    'Link to {{n}} more events on {{date}}': 'Povezava do {{n}} drugih dogodkov dne {{date}}',
    'Link to 1 more event on {{date}}': 'Povezava do še enega dogodka dne {{date}}',
    CW: 'Teden {{week}}',
};

const timePickerSlSI = {
    Time: 'Čas',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Prekliči',
    OK: 'V redu',
    'Select time': 'Izberite čas',
};

const slSI = {
    ...datePickerSlSI,
    ...calendarSlSI,
    ...timePickerSlSI,
};

const datePickerFiFI = {
    Date: 'Päivämäärä',
    'MM/DD/YYYY': 'VVVV-KK-PP',
    'Next month': 'Seuraava kuukausi',
    'Previous month': 'Edellinen kuukausi',
    'Choose Date': 'Valitse päivämäärä',
};

const calendarFiFI = {
    Today: 'Tänään',
    Month: 'Kuukausi',
    Week: 'Viikko',
    Day: 'Päivä',
    'Select View': 'Valitse näkymä',
    events: 'tapahtumaa',
    event: 'tapahtuma',
    'No events': 'Ei tapahtumia',
    'Next period': 'Seuraava ajanjakso',
    'Previous period': 'Edellinen ajanjakso',
    to: '-', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Koko ja usean päivän tapahtumat',
    'Link to {{n}} more events on {{date}}': 'Linkki {{n}} lisätapahtumaan päivämäärällä {{date}}',
    'Link to 1 more event on {{date}}': 'Linkki 1 lisätapahtumaan päivämäärällä {{date}}',
    CW: 'Viikko {{week}}',
};

const timePickerFiFI = {
    Time: 'Aika',
    AM: 'ap.',
    PM: 'ip.',
    Cancel: 'Peruuta',
    OK: 'OK',
    'Select time': 'Valitse aika',
};

const fiFI = {
    ...datePickerFiFI,
    ...calendarFiFI,
    ...timePickerFiFI,
};

const datePickerRoRO = {
    Date: 'Data',
    'MM/DD/YYYY': 'LL/ZZ/AAAA',
    'Next month': 'Luna următoare',
    'Previous month': 'Luna anterioară',
    'Choose Date': 'Alege data',
};

const calendarRoRO = {
    Today: 'Astăzi',
    Month: 'Lună',
    Week: 'Săptămână',
    Day: 'Zi',
    'Select View': 'Selectează vizualizarea',
    events: 'evenimente',
    event: 'eveniment',
    'No events': 'Fără evenimente',
    'Next period': 'Perioada următoare',
    'Previous period': 'Perioada anterioară',
    to: 'până la', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'Evenimente pe durata întregii zile și pe durata mai multor zile',
    'Link to {{n}} more events on {{date}}': 'Link către {{n}} evenimente suplimentare pe {{date}}',
    'Link to 1 more event on {{date}}': 'Link către 1 eveniment suplimentar pe {{date}}',
    CW: 'Săptămâna {{week}}',
};

const timePickerRoRO = {
    Time: 'Timp',
    AM: 'AM',
    PM: 'PM',
    Cancel: 'Anulează',
    OK: 'OK',
    'Select time': 'Selectați ora',
};

const roRO = {
    ...datePickerRoRO,
    ...calendarRoRO,
    ...timePickerRoRO,
};

class InvalidLocaleError extends Error {
    constructor(locale) {
        super(`Invalid locale: ${locale}`);
    }
}

const translate = (locale, languages) => (key, translationVariables) => {
    if (!/^[a-z]{2}-[A-Z]{2}$/.test(locale.value) &&
        'sr-Latn-RS' !== locale.value) {
        throw new InvalidLocaleError(locale.value);
    }
    const deHyphenatedLocale = locale.value.replaceAll('-', '');
    const language = languages.value[deHyphenatedLocale];
    if (!language)
        return key;
    let translation = language[key] || key;
    Object.keys(translationVariables || {}).forEach((variable) => {
        const value = String(translationVariables === null || translationVariables === void 0 ? void 0 : translationVariables[variable]);
        if (!value)
            return;
        translation = translation.replace(`{{${variable}}}`, value);
    });
    return translation;
};

const datePickerHeIL = {
    Date: 'תַאֲרִיך',
    'MM/DD/YYYY': 'MM/DD/YYYY',
    'Next month': 'חודש הבא',
    'Previous month': 'חודש קודם',
    'Choose Date': 'בחר תאריך',
};

const calendarHeIL = {
    Today: 'הַיוֹם',
    Month: 'חוֹדֶשׁ',
    Week: 'שָׁבוּעַ',
    Day: 'יוֹם',
    'Select View': 'בחר תצוגה',
    events: 'אירועים',
    event: 'אירוע',
    'No events': 'אין אירועים',
    'Next period': 'תקופה הבאה',
    'Previous period': 'תקופה קודמת',
    to: 'עד', // as in 2/1/2020 to 2/2/2020
    'Full day- and multiple day events': 'אירועים לכל היום ולמספר ימים',
    'Link to {{n}} more events on {{date}}': 'קישור לעוד {{n}} אירועים ב-{{date}}',
    'Link to 1 more event on {{date}}': 'קישור לאירוע נוסף ב-{{date}}',
    CW: '{{week}} שָׁבוּעַ',
};

const timePickerHeIL = {
    Time: 'שעה',
    AM: 'לפנה"צ',
    PM: 'אחה"צ',
    Cancel: 'ביטול',
    OK: 'אישור',
    'Select time': 'בחר שעה',
};

const heIL = {
    ...datePickerHeIL,
    ...calendarHeIL,
    ...timePickerHeIL,
};

const translations$1 = {
    deDE,
    enUS,
    itIT,
    enGB,
    svSE,
    zhCN,
    zhTW,
    jaJP,
    ruRU,
    koKR,
    frFR,
    daDK,
    mkMK,
    plPL,
    heIL,
    esES,
    nlNL,
    ptBR,
    skSK,
    trTR,
    kyKG,
    idID,
    csCZ,
    etEE,
    ukUA,
    caES,
    srLatnRS,
    srRS,
    ltLT,
    hrHR,
    slSI,
    fiFI,
    roRO,
};

const createAppSingleton = (config = {}) => {
    const configInternal = new ConfigBuilder()
        .withFirstDayOfWeek(config.firstDayOfWeek)
        .withLocale(config.locale)
        .withMin(config.min)
        .withMax(config.max)
        .withPlacement(config.placement)
        .withListeners(config.listeners)
        .withStyle(config.style)
        .withTeleportTo(config.teleportTo)
        .withLabel(config.label)
        .withName(config.name)
        .withDisabled(config.disabled)
        .build();
    const timeUnitsImpl = new TimeUnitsBuilder()
        .withConfig(configInternal)
        .build();
    return new DatePickerAppSingletonBuilder()
        .withConfig(configInternal)
        .withDatePickerState(createDatePickerState(configInternal, config.selectedDate))
        .withTimeUnitsImpl(timeUnitsImpl)
        .withTranslate(translate(configInternal.locale, signals.signal(translations$1)))
        .build();
};
const createDatePicker = (config) => {
    const $app = createAppSingleton(config);
    return new DatePickerApp($app);
};

function DatePicker({ initialValue, label, onChange, isDarkMode, name, width, disabled, min, max, locale, placement, }) {
    const [datePickerId] = hooks.useState(randomStringId$2);
    const [datePicker] = hooks.useState(() => createDatePicker({
        selectedDate: initialValue || toDateString$2(new Date()),
        teleportTo: document.body,
        label,
        name,
        min,
        max,
        locale,
        placement: placement || 'bottom-start',
        listeners: {
            onChange,
            onEscapeKeyDown: ($app) => {
                window.__sx_escapeKeyDownBlocker__ = true;
                $app.datePickerState.close();
                setTimeout(() => {
                    window.__sx_escapeKeyDownBlocker__ = false;
                }, 10);
            },
        },
        style: {
            dark: isDarkMode,
            fullWidth: width === '100%',
        },
    }));
    hooks.useEffect(() => {
        const datePickerEl = document.getElementById(datePickerId);
        if (datePickerEl) {
            datePicker.render(datePickerEl);
        }
    }, []);
    hooks.useEffect(() => {
        datePicker.disabled = disabled || false;
    }, [disabled]);
    hooks.useEffect(() => {
        if (!initialValue)
            return;
        datePicker.value = initialValue;
    }, [initialValue]);
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { className: 'sx__date-picker-outer-wrapper', id: datePickerId }) }));
}

function Textarea({ initialValue, onChange, label, name, errorMessage, placeholder, }) {
    const [inputValue, setInputValue] = hooks.useState(initialValue);
    const handleInput = (newValue) => {
        setInputValue(newValue);
        onChange(newValue);
    };
    const BASE_WRAPPER_CLASS = 'sx__textarea-wrapper';
    const [wrapperClasses, setWrapperClasses] = hooks.useState([BASE_WRAPPER_CLASS]);
    hooks.useEffect(() => {
        if (inputValue.length > 0) {
            setWrapperClasses([BASE_WRAPPER_CLASS, 'sx__has-value']);
        }
        else {
            setWrapperClasses([BASE_WRAPPER_CLASS]);
        }
    }, [inputValue]);
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { class: "sx__form-field", children: [jsxRuntime.jsxs("div", { className: wrapperClasses.join(' '), children: [jsxRuntime.jsx("textarea", { className: 'sx__textarea-input', value: inputValue, onInput: (e) => handleInput(e.currentTarget.value), id: "last_name", name: name, placeholder: placeholder }), jsxRuntime.jsx("label", { className: 'sx__textarea-label', htmlFor: name, children: label })] }), errorMessage && jsxRuntime.jsx("p", { className: "sx__error-message", children: errorMessage })] }) }));
}

function AppCheckbox({ initialValue, label, onChange, colorPrimary }) {
    const checkboxId = randomStringId$2();
    const [isChecked, setIsChecked] = hooks.useState(initialValue || false);
    const [isReady, setIsReady] = hooks.useState(!colorPrimary);
    const handleOnInput = (event) => {
        setIsChecked(event.target.checked);
        onChange(event.target.checked);
    };
    hooks.useEffect(() => {
        const el = document.getElementById(checkboxId);
        if (!el)
            return;
        if (colorPrimary) {
            el.style.setProperty('--sx-color-primary', colorPrimary);
            setIsReady(true);
        }
    }, []);
    return (jsxRuntime.jsx(preact.Fragment, { children: jsxRuntime.jsx("label", { id: checkboxId, className: "sx__app-checkbox", children: isReady && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("input", { type: "checkbox", checked: isChecked, onInput: handleOnInput }), jsxRuntime.jsx("span", { children: label })] })) }) }));
}

const AppContext = preact.createContext({});

/**
 * Can be used for generating a random id for an entity
 * Should, however, never be used in potentially resource intense loops,
 * since the performance cost of this compared to new Date().getTime() is ca x4 in v8
 * */
const randomStringId = () => 's' + Math.random().toString(36).substring(2, 11);

function AppInput() {
    var _a;
    const $app = compat.useContext(AppContext);
    const inputId = randomStringId();
    const wrapperId = randomStringId();
    const [wrapperClasses, setWrapperClasses] = hooks.useState([]);
    compat.useEffect(() => {
        const newClasses = ['sx__time-input-wrapper'];
        if ($app.timePickerState.isOpen.value)
            newClasses.push('sx__time-input--active');
        setWrapperClasses(newClasses);
    }, [$app.timePickerState.isOpen.value]);
    const openPopup = () => {
        if (!$app.config.teleportTo.value) {
            $app.timePickerState.isOpen.value = true;
            return;
        }
        const inputWrapperElement = document.getElementById(wrapperId);
        $app.timePickerState.inputWrapperElement.value =
            inputWrapperElement instanceof HTMLDivElement
                ? inputWrapperElement
                : undefined;
        $app.timePickerState.isOpen.value = true;
    };
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { id: wrapperId, className: wrapperClasses.join(' '), children: [jsxRuntime.jsx("label", { htmlFor: inputId, className: "sx__time-input-label", children: (_a = $app.config.label.value) !== null && _a !== void 0 ? _a : $app.translate('Time') }), jsxRuntime.jsx("input", { value: $app.timePickerState.currentTimeDisplayedValue.value, readOnly: true, id: inputId, name: $app.config.name.value ? $app.config.name.value : 'time', className: "sx__time-picker-input", type: "text", onFocus: openPopup })] }) }));
}

/**
 * Push a task to the end of the current call stack
 * */
const nextTick = (cb) => {
    setTimeout(() => {
        cb();
    });
};

function TimeInput({ initialValue, onChange, inputRef, nextTabIndexRef, validRange, }) {
    const [inputValue, setInputValue] = hooks.useState(initialValue);
    const [tabBlocker, setTabBlocker] = hooks.useState(false);
    const handleInput = (e) => {
        if (!(e.target instanceof HTMLInputElement))
            return;
        setInputValue(e.target.value);
    };
    compat.useEffect(() => {
        var _a;
        onChange(inputValue);
        if (tabBlocker)
            return;
        if (inputValue.length === 2 &&
            nextTabIndexRef &&
            'current' in nextTabIndexRef) {
            (_a = nextTabIndexRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            if (nextTabIndexRef.current instanceof HTMLInputElement) {
                nextTabIndexRef.current.select();
            }
        }
    }, [inputValue]);
    const handleOnBlur = () => {
        const [min, max] = validRange;
        const value = +inputValue;
        if (value < min || value > max || isNaN(value)) {
            setInputValue(min < 10 ? `0${min}` : String(min));
            return;
        }
        if (inputValue.length === 1) {
            setInputValue(`0${inputValue}`);
        }
    };
    const incrementOrDecrementOnKeyDown = (e) => {
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            const [min, max] = validRange;
            const value = +inputValue;
            const newValue = e.key === 'ArrowUp' ? value + 1 : value - 1;
            if (newValue < min || newValue > max)
                return;
            setInputValue(newValue < 10 ? `0${newValue}` : String(newValue));
            setTabBlocker(true);
            nextTick(() => setTabBlocker(false));
        }
    };
    return (jsxRuntime.jsx("input", { ref: inputRef, maxLength: 2, className: "sx__time-input", type: "text", onKeyDown: incrementOrDecrementOnKeyDown, value: inputValue, onInput: handleInput, onBlur: handleOnBlur }));
}

const isScrollable$1 = (el) => {
    if (el) {
        const hasScrollableContent = el.scrollHeight > el.clientHeight;
        const overflowYStyle = window.getComputedStyle(el).overflowY;
        const isOverflowHidden = overflowYStyle.indexOf('hidden') !== -1;
        return hasScrollableContent && !isOverflowHidden;
    }
    return true;
};
const getScrollableParents$1 = (el, acc = []) => {
    if (!el ||
        el === document.body ||
        el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        acc.push(window);
        return acc;
    }
    if (isScrollable$1(el)) {
        acc.push(el);
    }
    return getScrollableParents$1((el.assignedSlot
        ? el.assignedSlot.parentNode
        : el.parentNode), acc);
};

const convert12HourTo24HourTimeString = (hoursValue, minutesValue, $app) => {
    const hoursInt = Number(hoursValue);
    const isAM = $app.timePickerState.isAM.value;
    if (isAM && hoursInt === 12) {
        $app.timePickerState.currentTime.value = `00:${minutesValue}`;
    }
    else if (!isAM && hoursInt < 12) {
        $app.timePickerState.currentTime.value = `${hoursInt + 12}:${minutesValue}`;
    }
    else {
        $app.timePickerState.currentTime.value = `${hoursValue}:${minutesValue}`;
    }
};

function AppPopup() {
    const $app = compat.useContext(AppContext);
    const POPUP_CLASS_NAME = 'sx__time-picker-popup';
    const INPUT_WRAPPER_CLASS_NAME = 'sx__time-input-wrapper';
    const hoursRef = compat.useRef(null);
    const minutesRef = compat.useRef(null);
    const OKButtonRef = compat.useRef(null);
    const classList = compat.useMemo(() => {
        const returnValue = [
            POPUP_CLASS_NAME,
            $app.config.dark.value ? 'is-dark' : '',
        ];
        if (!$app.config.teleportTo.value && $app.config.placement.value) {
            returnValue.push($app.config.placement.value);
        }
        return returnValue;
    }, [$app.config.dark.value, $app.config.placement.value]);
    const getInitialStart12Hour = (hours) => {
        const hoursInt = Number(hours);
        if (hoursInt === 0)
            return '12';
        if (hoursInt > 12)
            return String(hoursInt - 12);
        return hours;
    };
    const [initialStart, initialEnd] = $app.timePickerState.currentTime.value.split(':');
    const [hoursValue, setHoursValue] = hooks.useState($app.config.is12Hour.value
        ? getInitialStart12Hour(initialStart)
        : initialStart);
    const [minutesValue, setMinutesValue] = hooks.useState(initialEnd);
    const clickOutsideListener = (event) => {
        const target = event.target;
        if (![POPUP_CLASS_NAME, INPUT_WRAPPER_CLASS_NAME].some((className) => target.closest(`.${className}`))) {
            $app.timePickerState.isOpen.value = false;
        }
    };
    const escapeKeyListener = (e) => {
        if (e.key === 'Escape') {
            if (typeof $app.config.onEscapeKeyDown.value === 'function') {
                $app.config.onEscapeKeyDown.value($app);
            }
            else {
                $app.timePickerState.isOpen.value = false;
            }
        }
    };
    hooks.useEffect(() => {
        var _a, _b;
        (_a = hoursRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        (_b = hoursRef.current) === null || _b === void 0 ? void 0 : _b.select();
        document.addEventListener('click', clickOutsideListener);
        document.addEventListener('keydown', escapeKeyListener);
        return () => {
            document.removeEventListener('click', clickOutsideListener);
            document.removeEventListener('keydown', escapeKeyListener);
        };
    }, []);
    const handleAccept = () => {
        if ($app.config.is12Hour.value) {
            convert12HourTo24HourTimeString(hoursValue, minutesValue, $app);
        }
        else {
            $app.timePickerState.currentTime.value = `${hoursValue}:${minutesValue}`;
        }
        $app.timePickerState.isOpen.value = false;
    };
    const remSize = Number(getComputedStyle(document.documentElement).fontSize.split('px')[0]);
    const popupHeight = 362;
    const popupWidth = 332;
    const getFixedPositionStyles = () => {
        var _a, _b, _c;
        const inputRect = (_a = $app.timePickerState.inputWrapperElement.value) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
        if (!inputRect)
            return undefined;
        return {
            top: ((_b = $app.config.placement.value) === null || _b === void 0 ? void 0 : _b.includes('bottom'))
                ? inputRect.height + inputRect.y + 1 // 1px border
                : inputRect.y - remSize - popupHeight, // subtract remsize to leave room for label text
            left: ((_c = $app.config.placement.value) === null || _c === void 0 ? void 0 : _c.includes('start'))
                ? inputRect.x
                : inputRect.x + inputRect.width - popupWidth,
            width: popupWidth,
            position: 'fixed',
        };
    };
    const [fixedPositionStyle, setFixedPositionStyle] = hooks.useState(getFixedPositionStyles());
    hooks.useEffect(() => {
        const inputWrapperEl = $app.timePickerState.inputWrapperElement.value;
        if (!inputWrapperEl)
            return;
        const scrollableParents = getScrollableParents$1(inputWrapperEl);
        scrollableParents.forEach((parent) => parent.addEventListener('scroll', () => setFixedPositionStyle(getFixedPositionStyles())));
        return () => {
            scrollableParents.forEach((parent) => parent.removeEventListener('scroll', () => setFixedPositionStyle(getFixedPositionStyles())));
        };
    }, []);
    return (jsxRuntime.jsxs("div", { className: classList.join(' '), style: $app.config.teleportTo.value ? fixedPositionStyle : undefined, children: [jsxRuntime.jsx("div", { className: "sx__time-picker-popup-label", children: $app.translate('Select time') }), jsxRuntime.jsxs("div", { className: "sx__time-picker-time-inputs", children: [jsxRuntime.jsx(TimeInput, { initialValue: hoursValue, onChange: (newHours) => setHoursValue(newHours), inputRef: hoursRef, nextTabIndexRef: minutesRef, validRange: $app.config.is12Hour.value ? [1, 12] : [0, 23] }), jsxRuntime.jsx("span", { className: "sx__time-picker-colon", children: ":" }), jsxRuntime.jsx(TimeInput, { initialValue: minutesValue, onChange: (newMinutes) => setMinutesValue(newMinutes), inputRef: minutesRef, validRange: [0, 59], nextTabIndexRef: OKButtonRef }), $app.config.is12Hour.value && (jsxRuntime.jsxs("div", { className: "sx__time-picker-12-hour-switches", children: [jsxRuntime.jsx("button", { type: "button", className: `sx__time-picker-12-hour-switch${$app.timePickerState.isAM.value ? ' is-selected' : ''}`, onClick: () => ($app.timePickerState.isAM.value = true), children: $app.translate('AM') }), jsxRuntime.jsx("button", { type: "button", className: `sx__time-picker-12-hour-switch${!$app.timePickerState.isAM.value ? ' is-selected' : ''}`, onClick: () => ($app.timePickerState.isAM.value = false), children: $app.translate('PM') })] }))] }), jsxRuntime.jsxs("div", { class: "sx__time-picker-actions", children: [jsxRuntime.jsx("button", { type: "button", class: "sx__time-picker-action sx__ripple sx__button-cancel", onClick: () => ($app.timePickerState.isOpen.value = false), children: $app.translate('Cancel') }), jsxRuntime.jsx("button", { ref: OKButtonRef, type: "button", class: "sx__time-picker-action sx__ripple sx__button-accept", onClick: handleAccept, children: $app.translate('OK') })] })] }));
}

function TimePickerWrapper({ $app }) {
    const baseClassList = [
        'sx__time-picker-wrapper',
        $app.config.is12Hour.value ? 'is-12-hour' : '',
    ];
    const [classList, setClassList] = hooks.useState(baseClassList);
    hooks.useEffect(() => {
        setClassList([...baseClassList, $app.config.dark.value ? 'is-dark' : '']);
    }, [$app.config.dark.value]);
    let AppPopupJSX = jsxRuntime.jsx(AppPopup, {});
    if ($app.config.teleportTo.value) {
        AppPopupJSX = compat.createPortal(AppPopupJSX, $app.config.teleportTo.value);
    }
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { className: classList.join(' '), children: jsxRuntime.jsxs(AppContext.Provider, { value: $app, children: [jsxRuntime.jsx(AppInput, {}), $app.timePickerState.isOpen.value && AppPopupJSX] }) }) }));
}

class TimePickerApp {
    constructor($app) {
        Object.defineProperty(this, "$app", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: $app
        });
    }
    render(el) {
        preact.render(preact.createElement(TimePickerWrapper, {
            $app: this.$app,
        }), el);
    }
    get value() {
        return this.$app.timePickerState.currentTime.value;
    }
    set value(value) {
        this.$app.timePickerState.currentTime.value = value;
    }
}

const getTimePickerState = (config, is12HourClock) => {
    var _a;
    const currentTime = signals.signal((_a = config.initialValue) !== null && _a !== void 0 ? _a : '00:00');
    let wasInitialized = false;
    const handleCurrentTimeChanged = (config, currentTime) => {
        if (!wasInitialized)
            return (wasInitialized = true);
        if (config.onChange) {
            config.onChange(currentTime);
        }
    };
    signals.effect(() => {
        handleCurrentTimeChanged(config, currentTime.value);
    });
    const initialIsAM = parseInt(currentTime.value.split(':')[0]) < 12;
    const isAM = signals.signal(initialIsAM);
    return {
        isOpen: signals.signal(false),
        currentTime,
        currentTimeDisplayedValue: signals.computed(() => {
            const [hours, minutes] = currentTime.value.split(':');
            const parsedHours = parseInt(hours);
            let hoursInt = parsedHours;
            const minutesInt = parseInt(minutes);
            if (is12HourClock) {
                hoursInt = hoursInt === 0 ? 12 : hoursInt;
                const hours12 = hoursInt > 12 ? hoursInt - 12 : hoursInt;
                return `${hours12}:${minutesInt.toString().padStart(2, '0')} ${parsedHours >= 12 ? 'PM' : 'AM'}`;
            }
            return `${hoursInt.toString().padStart(2, '0')}:${minutesInt.toString().padStart(2, '0')}`;
        }),
        inputWrapperElement: signals.signal(undefined),
        isAM,
    };
};
const createTimePickerAppContext = (config = {}, translateFn) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return ({
        config: {
            onEscapeKeyDown: signals.signal((_a = config.onEscapeKeyDown) !== null && _a !== void 0 ? _a : undefined),
            dark: signals.signal((_b = config.dark) !== null && _b !== void 0 ? _b : false),
            placement: signals.signal((_c = config.placement) !== null && _c !== void 0 ? _c : 'bottom-start'),
            teleportTo: signals.signal((_d = config.teleportTo) !== null && _d !== void 0 ? _d : null),
            label: signals.signal((_e = config.label) !== null && _e !== void 0 ? _e : null),
            is12Hour: signals.signal((_f = config.is12Hour) !== null && _f !== void 0 ? _f : false),
            name: signals.signal((_g = config.name) !== null && _g !== void 0 ? _g : ''),
        },
        timePickerState: getTimePickerState(config, (_h = config.is12Hour) !== null && _h !== void 0 ? _h : false),
        translate: translateFn,
    });
};
const createTimePicker = (config = {}, translateFn) => {
    return new TimePickerApp(createTimePickerAppContext(config, translateFn));
};

function TimePicker({ initialValue, label, name, onChange, placement, isDarkMode, is12Hour, $app, }) {
    const [timePickerId] = hooks.useState(randomStringId$2);
    const [timePicker] = hooks.useState(createTimePicker({
        initialValue: initialValue || '00:00',
        teleportTo: document.body,
        label,
        name,
        onChange,
        placement: placement || 'bottom-start',
        dark: isDarkMode,
        is12Hour: is12Hour || false,
        onEscapeKeyDown: ($app) => {
            window.__sx_escapeKeyDownBlocker__ = true;
            $app.timePickerState.isOpen.value = false;
            setTimeout(() => {
                window.__sx_escapeKeyDownBlocker__ = false;
            }, 10);
        },
    }, $app.translate));
    hooks.useEffect(() => {
        const timePickerElement = document.getElementById(timePickerId);
        if (timePickerElement) {
            timePicker.render(timePickerElement);
        }
    }, []);
    hooks.useEffect(() => {
        if (!initialValue)
            return;
        timePicker.value = initialValue;
    }, [initialValue]);
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { id: timePickerId }) }));
}

const isScrollable = (el) => {
    if (el) {
        const hasScrollableContent = el.scrollHeight > el.clientHeight;
        const overflowYStyle = window.getComputedStyle(el).overflowY;
        const isOverflowHidden = overflowYStyle.indexOf('hidden') !== -1;
        return hasScrollableContent && !isOverflowHidden;
    }
    return true;
};
const getScrollableParents = (el, acc = []) => {
    if (!el ||
        el === document.body ||
        el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        acc.push(window);
        return acc;
    }
    if (isScrollable(el)) {
        acc.push(el);
    }
    return getScrollableParents((el.assignedSlot
        ? el.assignedSlot.parentNode
        : el.parentNode), acc);
};

function AppCombobox({ items, label, initialSelectedItems, onChange, name, isDarkMode, errorMessage, placeholder, }) {
    const wrapperId = randomStringId$2();
    const listId = randomStringId$2();
    const inputId = randomStringId$2();
    const [wrapperRect, setWrapperRect] = hooks.useState({
        x: 0,
        y: 0,
        height: 0,
        width: 0,
    });
    const [isOpen, setIsOpen] = hooks.useState(false);
    const [listClasses, setListClasses] = hooks.useState('sx__app-combobox__list');
    const [filteredItems, setFilteredItems] = hooks.useState(items);
    const [selectedItems, setSelectedItems] = hooks.useState(initialSelectedItems || []);
    hooks.useEffect(() => {
        const baseClasses = ['sx__app-combobox__list'];
        if (isDarkMode)
            baseClasses.push('is-dark');
        if (isOpen)
            baseClasses.push('is-open');
        setListClasses(baseClasses.join(' '));
    }, [isOpen, isDarkMode]);
    const setPopupPosition = (wrapperEl) => {
        setWrapperRect({
            x: wrapperEl.getBoundingClientRect().left,
            y: wrapperEl.getBoundingClientRect().top,
            height: wrapperEl.getBoundingClientRect().height,
            width: wrapperEl.getBoundingClientRect().width,
        });
    };
    const toggleOpen = () => {
        if (isOpen) {
            setIsOpen(false);
            return;
        }
        const wrapperEl = document.getElementById(wrapperId);
        const inputEl = document.getElementById(inputId);
        if (!wrapperEl || !inputEl)
            return;
        inputEl.focus();
        setIsOpen(true);
        setPopupPosition(wrapperEl);
        const scrollableParents = getScrollableParents(wrapperEl);
        const boundSetPosition = setPopupPosition.bind(null, wrapperEl);
        const listClickOutsideListener = (event) => {
            const target = event.target;
            if (target instanceof HTMLElement && !target.closest(`#${listId}`)) {
                setIsOpen(false);
                document.removeEventListener('click', listClickOutsideListener);
                scrollableParents.forEach((parentEl) => parentEl.removeEventListener('scroll', boundSetPosition));
            }
        };
        setTimeout(() => {
            scrollableParents.forEach((parentEl) => parentEl.addEventListener('scroll', boundSetPosition));
            document.addEventListener('click', listClickOutsideListener);
        }, 10);
    };
    const handleBackSpace = () => {
        const lastItem = selectedItems[selectedItems.length - 1];
        setSelectedItems(selectedItems.filter((item) => item !== lastItem));
    };
    const handleInput = (e) => {
        const target = e.target;
        if (!(target instanceof HTMLInputElement))
            return;
        const value = target.value;
        if (value.length === 0) {
            setFilteredItems(items.filter((item) => !selectedItems.includes(item)));
            return;
        }
        const filtered = items.filter((item) => {
            return (item.toLowerCase().includes(value.toLowerCase()) &&
                !selectedItems.includes(item));
        });
        setFilteredItems(filtered);
    };
    const clickOnItem = (item) => {
        setSelectedItems([...selectedItems, item]);
        const inputEl = document.getElementById(inputId);
        if (!(inputEl instanceof HTMLInputElement))
            return;
        inputEl.value = '';
    };
    hooks.useEffect(() => {
        const filtered = items.filter((item) => !selectedItems.includes(item));
        setFilteredItems(filtered);
        onChange(selectedItems);
    }, [selectedItems]);
    // @ts-ignore
    const handleKeyDown = (e) => {
        if (e.key === 'Backspace' && e.target instanceof HTMLInputElement) {
            if (e.target.value.length === 0) {
                handleBackSpace();
            }
        }
    };
    const removeSelected = (item) => {
        setSelectedItems(selectedItems.filter((i) => i !== item));
    };
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { class: "sx__form-field", children: [jsxRuntime.jsxs("div", { class: "sx__app-combobox-wrapper", id: wrapperId, onClick: toggleOpen, children: [jsxRuntime.jsxs("div", { class: "sx__app-combobox__input-wrapper", children: [selectedItems.map((item, index) => (jsxRuntime.jsxs("div", { class: "sx__app-combobox__chip", children: [item, jsxRuntime.jsx("span", { className: "sx__app-combobox__chip-remove", onClick: () => removeSelected(item), style: { width: '16px', height: '16px' }, children: jsxRuntime.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { "stroke-width": "0" }), jsxRuntime.jsx("g", { "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { children: [' ', jsxRuntime.jsx("path", { d: "M19 5L4.99998 19M5.00001 5L19 19", stroke: "#fff", "stroke-width": "2.4", "stroke-linecap": "round", "stroke-linejoin": "round" }), ' '] })] }) })] }, index))), jsxRuntime.jsx("input", { id: inputId, onInput: handleInput, onKeyDown: handleKeyDown, className: "sx__app-combobox-input", type: "text", placeholder: placeholder || 'Search...', name: name }), jsxRuntime.jsx("label", { className: 'sx__app-combobox-label', htmlFor: name, children: label })] }), compat.createPortal(jsxRuntime.jsx("div", { id: listId, class: listClasses, style: {
                                top: wrapperRect.y + wrapperRect.height + 1,
                                left: wrapperRect.x,
                                width: wrapperRect.width,
                            }, children: jsxRuntime.jsx("ul", { children: filteredItems.map((item, index) => (jsxRuntime.jsx("li", { onClick: () => clickOnItem(item), children: item }, index))) }) }), document.body)] }), errorMessage && jsxRuntime.jsx("p", { className: "sx__error-message", children: errorMessage })] }) }));
}

const WarningSign = ({ color = '#a88d00' }) => {
    return (jsxRuntime.jsxs("svg", { fill: color, width: 24, height: 24, viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", strokeWidth: "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntime.jsx("g", { id: "SVGRepo_iconCarrier", children: jsxRuntime.jsx("path", { "fill-rule": "evenodd", d: "M23,7.44365081 L23,16.5563492 L16.5563492,23 L7.44365081,23 L1,16.5563492 L1,7.44365081 L7.44365081,1 L16.5563492,1 L23,7.44365081 Z M15.7279221,3 L8.27207794,3 L3,8.27207794 L3,15.7279221 L8.27207794,21 L15.7279221,21 L21,15.7279221 L21,8.27207794 L15.7279221,3 Z M12.0003283,17.9983464 C11.4478622,17.9983464 11,17.5506311 11,16.9983464 C11,16.4460616 11.4478622,15.9983464 12.0003283,15.9983464 C12.5527943,15.9983464 13.0006565,16.4460616 13.0006565,16.9983464 C13.0006565,17.5506311 12.5527943,17.9983464 12.0003283,17.9983464 Z M11.0029544,5.99834639 L13.0036109,5.99834639 L13.0036109,13.9983464 L11.0029544,13.9983464 L11.0029544,5.99834639 Z" }) })] }));
};

function AppComboboxSingleValue({ items, label, initialSelectedItem, onChange, name, isDarkMode, errorMessage, placeholder, }) {
    const wrapperId = randomStringId$2();
    const listId = randomStringId$2();
    const inputId = randomStringId$2();
    const [wrapperRect, setWrapperRect] = hooks.useState({
        x: 0,
        y: 0,
        height: 0,
        width: 0,
    });
    const [isOpen, setIsOpen] = hooks.useState(false);
    const [listClasses, setListClasses] = hooks.useState('sx__app-combobox__list');
    const [filteredItems, setFilteredItems] = hooks.useState(items);
    const [selectedItem, setSelectedItem] = hooks.useState(initialSelectedItem === null || initialSelectedItem === void 0 ? void 0 : initialSelectedItem.value);
    const setPopupPosition = (wrapperEl) => {
        setWrapperRect({
            x: wrapperEl.getBoundingClientRect().left,
            y: wrapperEl.getBoundingClientRect().top,
            height: wrapperEl.getBoundingClientRect().height,
            width: wrapperEl.getBoundingClientRect().width,
        });
    };
    hooks.useEffect(() => {
        const baseClasses = ['sx__app-combobox__list'];
        if (isDarkMode)
            baseClasses.push('is-dark');
        if (isOpen)
            baseClasses.push('is-open');
        setListClasses(baseClasses.join(' '));
    }, [isOpen, isDarkMode]);
    const toggleOpen = () => {
        if (isOpen) {
            setIsOpen(false);
            return;
        }
        const wrapperEl = document.getElementById(wrapperId);
        const inputEl = document.getElementById(inputId);
        if (!wrapperEl || !inputEl)
            return;
        inputEl.focus();
        setIsOpen(true);
        setPopupPosition(wrapperEl);
        const scrollableParents = getScrollableParents(wrapperEl);
        const boundSetPosition = setPopupPosition.bind(null, wrapperEl);
        const listClickOutsideListener = (event) => {
            const target = event.target;
            if (target instanceof HTMLElement && !target.closest(`#${listId}`)) {
                setIsOpen(false);
                document.removeEventListener('click', listClickOutsideListener);
                scrollableParents.forEach((parentEl) => parentEl.removeEventListener('scroll', boundSetPosition));
            }
        };
        setTimeout(() => {
            document.addEventListener('click', listClickOutsideListener);
            scrollableParents.forEach((parentEl) => parentEl.addEventListener('scroll', boundSetPosition));
        });
    };
    // @ts-ignore
    const handleInput = (e) => {
        const target = e.target;
        if (!(target instanceof HTMLInputElement))
            return;
        const value = target.value;
        if (value.length === 0) {
            setFilteredItems(items);
            return;
        }
        const filtered = items.filter((item) => {
            return { ...item }.label.toLowerCase().includes(value.toLowerCase());
        });
        setFilteredItems(filtered);
    };
    const clickOnItem = (item) => {
        var _a;
        setSelectedItem(item);
        const inputEl = document.getElementById(inputId);
        if (!(inputEl instanceof HTMLInputElement))
            return;
        inputEl.value = ((_a = items.find((i) => i.value === item)) === null || _a === void 0 ? void 0 : _a.label) || '';
    };
    const inputRef = hooks.useRef(null);
    hooks.useEffect(() => {
        var _a;
        setFilteredItems(items);
        onChange(selectedItem);
        if (!inputRef.current)
            return;
        inputRef.current.value =
            ((_a = items.find((i) => i.value === selectedItem)) === null || _a === void 0 ? void 0 : _a.label) || '';
    }, [selectedItem]);
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { class: "sx__form-field", children: [jsxRuntime.jsxs("div", { class: "sx__app-combobox-wrapper", id: wrapperId, onClick: toggleOpen, children: [jsxRuntime.jsxs("div", { class: "sx__app-combobox__input-wrapper", children: [jsxRuntime.jsx("input", { ref: inputRef, id: inputId, onInput: handleInput, className: "sx__app-combobox-input", type: "text", placeholder: placeholder || 'Search...', name: name }), jsxRuntime.jsx("label", { className: 'sx__app-combobox-label', htmlFor: name, children: label })] }), compat.createPortal(jsxRuntime.jsx("div", { id: listId, class: listClasses, style: {
                                top: wrapperRect.y + wrapperRect.height + 1,
                                left: wrapperRect.x,
                                width: wrapperRect.width,
                            }, children: jsxRuntime.jsx("ul", { children: filteredItems.map((item, index) => (jsxRuntime.jsx("li", { onClick: () => clickOnItem(item.value), children: item.label }, index))) }) }), document.body)] }), errorMessage && jsxRuntime.jsx("p", { className: "sx__error-message", children: errorMessage })] }) }));
}

const ADDED_EVENT_CLASS_NAME = 'sx-is-added-event';

const InfoIcon = ({ color = '#0077cc' }) => {
    return (jsxRuntime.jsxs("svg", { width: 28, height: 28, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { id: "SVGRepo_iconCarrier", children: [jsxRuntime.jsx("path", { d: "M12 16.75C11.8019 16.7474 11.6126 16.6676 11.4725 16.5275C11.3324 16.3874 11.2526 16.1981 11.25 16V11C11.25 10.8011 11.329 10.6103 11.4697 10.4697C11.6103 10.329 11.8011 10.25 12 10.25C12.1989 10.25 12.3897 10.329 12.5303 10.4697C12.671 10.6103 12.75 10.8011 12.75 11V16C12.7474 16.1981 12.6676 16.3874 12.5275 16.5275C12.3874 16.6676 12.1981 16.7474 12 16.75Z", fill: color }), jsxRuntime.jsx("path", { d: "M12 9.25C11.8019 9.24741 11.6126 9.16756 11.4725 9.02747C11.3324 8.88737 11.2526 8.69811 11.25 8.5V8C11.25 7.80109 11.329 7.61032 11.4697 7.46967C11.6103 7.32902 11.8011 7.25 12 7.25C12.1989 7.25 12.3897 7.32902 12.5303 7.46967C12.671 7.61032 12.75 7.80109 12.75 8V8.5C12.7474 8.69811 12.6676 8.88737 12.5275 9.02747C12.3874 9.16756 12.1981 9.24741 12 9.25Z", fill: color }), jsxRuntime.jsx("path", { d: "M12 21C10.22 21 8.47991 20.4722 6.99987 19.4832C5.51983 18.4943 4.36628 17.0887 3.68509 15.4442C3.0039 13.7996 2.82567 11.99 3.17294 10.2442C3.5202 8.49836 4.37737 6.89472 5.63604 5.63604C6.89472 4.37737 8.49836 3.5202 10.2442 3.17294C11.99 2.82567 13.7996 3.0039 15.4442 3.68509C17.0887 4.36628 18.4943 5.51983 19.4832 6.99987C20.4722 8.47991 21 10.22 21 12C21 14.387 20.0518 16.6761 18.364 18.364C16.6761 20.0518 14.387 21 12 21ZM12 4.5C10.5166 4.5 9.0666 4.93987 7.83323 5.76398C6.59986 6.58809 5.63856 7.75943 5.07091 9.12988C4.50325 10.5003 4.35473 12.0083 4.64411 13.4632C4.9335 14.918 5.64781 16.2544 6.6967 17.3033C7.7456 18.3522 9.08197 19.0665 10.5368 19.3559C11.9917 19.6453 13.4997 19.4968 14.8701 18.9291C16.2406 18.3614 17.4119 17.4001 18.236 16.1668C19.0601 14.9334 19.5 13.4834 19.5 12C19.5 10.0109 18.7098 8.10323 17.3033 6.6967C15.8968 5.29018 13.9891 4.5 12 4.5Z", fill: color })] })] }));
};

function AppSelect({ items, label, initialSelectedItem, onChange, name, isDarkMode, errorMessage, }) {
    const wrapperId = randomStringId$2();
    const listId = randomStringId$2();
    const inputId = randomStringId$2();
    const [wrapperRect, setWrapperRect] = hooks.useState({
        x: 0,
        y: 0,
        height: 0,
        width: 0,
    });
    const [isOpen, setIsOpen] = hooks.useState(false);
    const [listClasses, setListClasses] = hooks.useState('sx__app-select__list');
    const [selectedItem, setSelectedItem] = hooks.useState((initialSelectedItem === null || initialSelectedItem === void 0 ? void 0 : initialSelectedItem.value) || '');
    const setPopupPosition = (wrapperEl) => {
        setWrapperRect({
            x: wrapperEl.getBoundingClientRect().left,
            y: wrapperEl.getBoundingClientRect().top,
            height: wrapperEl.getBoundingClientRect().height,
            width: wrapperEl.getBoundingClientRect().width,
        });
    };
    hooks.useEffect(() => {
        const baseClasses = ['sx__app-select__list'];
        if (isDarkMode)
            baseClasses.push('is-dark');
        if (isOpen)
            baseClasses.push('is-open');
        setListClasses(baseClasses.join(' '));
    }, [isOpen, isDarkMode]);
    const toggleOpen = () => {
        if (isOpen) {
            setIsOpen(false);
            return;
        }
        const wrapperEl = document.getElementById(wrapperId);
        const inputEl = document.getElementById(inputId);
        if (!wrapperEl || !inputEl)
            return;
        inputEl.focus();
        setIsOpen(true);
        setPopupPosition(wrapperEl);
        const scrollableParents = getScrollableParents(wrapperEl);
        const boundSetPosition = setPopupPosition.bind(null, wrapperEl);
        const listClickOutsideListener = (event) => {
            const target = event.target;
            if (target instanceof HTMLElement && !target.closest(`#${listId}`)) {
                setIsOpen(false);
                document.removeEventListener('click', listClickOutsideListener);
                scrollableParents.forEach((parentEl) => parentEl.removeEventListener('scroll', boundSetPosition));
            }
        };
        setTimeout(() => {
            document.addEventListener('click', listClickOutsideListener);
            scrollableParents.forEach((parentEl) => parentEl.addEventListener('scroll', boundSetPosition));
        }, 10);
    };
    const clickOnItem = (item) => {
        var _a;
        setSelectedItem(item);
        const inputEl = document.getElementById(inputId);
        if (!(inputEl instanceof HTMLInputElement))
            return;
        inputEl.value = ((_a = items.find((i) => i.value === item)) === null || _a === void 0 ? void 0 : _a.label) || '';
        setIsOpen(false);
    };
    const inputRef = hooks.useRef(null);
    hooks.useEffect(() => {
        var _a;
        onChange(selectedItem);
        if (!inputRef.current)
            return;
        inputRef.current.value =
            ((_a = items.find((i) => i.value === selectedItem)) === null || _a === void 0 ? void 0 : _a.label) || '';
    }, [selectedItem]);
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { class: "sx__form-field", children: [jsxRuntime.jsxs("div", { class: "sx__app-select-wrapper", id: wrapperId, onClick: toggleOpen, children: [jsxRuntime.jsxs("div", { class: "sx__app-select__input-wrapper", children: [jsxRuntime.jsx("input", { ref: inputRef, id: inputId, className: "sx__app-select-input", type: "text", readOnly: true, name: name }), jsxRuntime.jsx("label", { className: 'sx__app-select-label', htmlFor: name, children: label })] }), compat.createPortal(jsxRuntime.jsx("div", { id: listId, class: listClasses, style: {
                                top: wrapperRect.y + wrapperRect.height + 1,
                                left: wrapperRect.x,
                                width: wrapperRect.width,
                            }, children: jsxRuntime.jsx("ul", { children: items.map((item, index) => (jsxRuntime.jsx("li", { onClick: () => clickOnItem(item.value), children: item.label }, index))) }) }), document.body)] }), errorMessage && jsxRuntime.jsx("p", { className: "sx__error-message", children: errorMessage })] }) }));
}

const toDateTimeString = (date) => {
    return `${toDateString$2(date)} ${toTimeString$1(date)}`;
};
/**
 * Converts a string of format 20240229T235959 to YYYY-MM-DD
 * */
const dateStringFromICalendarDateTime = (dateTime) => {
    const year = dateTime.slice(0, 4);
    const month = dateTime.slice(4, 6);
    const day = dateTime.slice(6, 8);
    return `${year}-${month}-${day}`;
};
/**
 * Converts a string of format 2024-01-01 to 20240101T235959
 * We need to add 23:59:59 to make the date inclusive when selecting an UNTIL date
 * */
const toICalendarDateTimeWithEndOfDay = (dateTime) => {
    return `${dateTime.replace(/-/g, '')}T235959`;
};

const rruleWeekdays = Object.freeze([
    'SU',
    'MO',
    'TU',
    'WE',
    'TH',
    'FR',
    'SA',
]);

const getFrequenciesIncludingNoneAndCustom = ($app) => {
    return [
        { label: $app.translate('Once'), value: '' },
        { label: $app.translate('Daily'), value: 'DAILY' },
        { label: $app.translate('Weekly'), value: 'WEEKLY' },
        { label: $app.translate('Monthly'), value: 'MONTHLY' },
        { label: $app.translate('Yearly'), value: 'YEARLY' },
        { label: $app.translate('Custom repetition'), value: 'custom' },
    ];
};
const getRealRruleFrequenciesPlural = ($app) => {
    return [
        { label: $app.translate('Days'), value: 'DAILY' },
        { label: $app.translate('Weeks'), value: 'WEEKLY' },
        { label: $app.translate('Months'), value: 'MONTHLY' },
        { label: $app.translate('Years'), value: 'YEARLY' },
    ];
};
const getRealRruleFrequenciesSingular = ($app) => {
    return [
        { label: $app.translate('Day'), value: 'DAILY' },
        { label: $app.translate('Week'), value: 'WEEKLY' },
        { label: $app.translate('Month'), value: 'MONTHLY' },
        { label: $app.translate('Year'), value: 'YEARLY' },
    ];
};
const getInitialFrequencyIncludingCustomOption = (modalPlugin, $app) => {
    var _a;
    const validFrequencies = getFrequenciesIncludingNoneAndCustom($app).map((f) => f.value);
    const rruleParts = modalPlugin.formValues.value.rrule
        ? modalPlugin.formValues.value.rrule.split(';')
        : [];
    const freqPart = rruleParts.find((part) => part.includes('FREQ'));
    const freq = freqPart ? freqPart.split('=')[1] : '';
    const untilPart = rruleParts.find((part) => part.includes('UNTIL'));
    const countPart = rruleParts.find((part) => part.includes('COUNT'));
    const intervalPart = rruleParts.find((part) => part.includes('INTERVAL'));
    const bydayPart = rruleParts.find((part) => part.includes('BYDAY'));
    if (untilPart || countPart || intervalPart || bydayPart) {
        return {
            label: $app.translate('Custom repetition'),
            value: 'custom',
        };
    }
    if (freq && !validFrequencies.includes(freq)) {
        throw new Error(`Unsupported frequency: ${freq}`);
    }
    return {
        label: ((_a = getFrequenciesIncludingNoneAndCustom($app).find((f) => f.value === freq)) === null || _a === void 0 ? void 0 : _a.label) || '',
        value: freq,
    };
};
const getInitialCustomRRuleFrequency = (modalPlugin, $app) => {
    var _a;
    const validFrequencies = getFrequenciesIncludingNoneAndCustom($app).map((f) => f.value);
    const rruleParts = modalPlugin.formValues.value.rrule
        ? modalPlugin.formValues.value.rrule.split(';')
        : [];
    const freqPart = rruleParts.find((part) => part.includes('FREQ'));
    let freq = freqPart ? freqPart.split('=')[1] : '';
    if (freq && !validFrequencies.includes(freq)) {
        throw new Error(`Unsupported frequency: ${freq}`);
    }
    if (!freq)
        freq = 'DAILY';
    return {
        label: ((_a = getFrequenciesIncludingNoneAndCustom($app).find((f) => f.value === freq)) === null || _a === void 0 ? void 0 : _a.label) || '',
        value: freq,
    };
};
const getInitialRruleUntil = (modalPlugin) => {
    if (modalPlugin.formValues.value.rrule) {
        const allRruleParts = modalPlugin.formValues.value.rrule.split(';');
        const untilPart = allRruleParts.find((part) => part.includes('UNTIL'));
        return untilPart
            ? dateStringFromICalendarDateTime(untilPart.split('=')[1])
            : '';
    }
};
const getInitialRruleCount = (modalPlugin) => {
    if (modalPlugin.formValues.value.rrule) {
        const allRruleParts = modalPlugin.formValues.value.rrule.split(';');
        const countPart = allRruleParts.find((part) => part.includes('COUNT'));
        return countPart ? Number(countPart.split('=')[1]) : 1;
    }
    return 1;
};
const getInitialRruleInterval = (modalPlugin) => {
    if (modalPlugin.formValues.value.rrule) {
        const allRruleParts = modalPlugin.formValues.value.rrule.split(';');
        const intervalPart = allRruleParts.find((part) => part.includes('INTERVAL'));
        const intervalPartValue = intervalPart === null || intervalPart === void 0 ? void 0 : intervalPart.split('=')[1];
        return intervalPartValue ? Number(intervalPartValue) : 1;
    }
    return 1;
};
const getInitialRruleByDay = (modalPlugin) => {
    if (modalPlugin.formValues.value.rrule) {
        const allRruleParts = modalPlugin.formValues.value.rrule.split(';');
        const freqPart = allRruleParts.find((part) => part.includes('FREQ'));
        const freqValue = freqPart === null || freqPart === void 0 ? void 0 : freqPart.split('=')[1];
        if (!freqValue)
            return undefined;
        if (freqValue !== 'WEEKLY')
            return undefined;
        const byDayPart = allRruleParts.find((part) => part.includes('BYDAY'));
        if (!byDayPart)
            return undefined;
        const allByDayParts = byDayPart.split('=')[1].split(',');
        // check that allByDayParts are included in rruleWeekdays, and otherwise log an error
        const invalidByDayParts = allByDayParts.filter((part) => !rruleWeekdays.includes(part));
        if (invalidByDayParts.length) {
            throw new Error(`Invalid BYDAY parts in rrule: ${invalidByDayParts.join(', ')}`);
        }
        return allByDayParts;
    }
};
const getWkstFromConfig = (config) => {
    const weekdays = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
    return weekdays[config.firstDayOfWeek.value];
};

const WeekdaySelector = ({ activeDays, onDayClick }) => {
    return (jsxRuntime.jsx("div", { className: "sx__weekday-selector", children: rruleWeekdays.map((day) => (jsxRuntime.jsx("button", { className: `sx__day-button ${activeDays.includes(day) ? 'sx__day-button--active' : ''}`, onClick: () => onDayClick(day), children: day }, day))) }));
};

function EventForm({ $app, removeEditAddedEvent }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34;
    const titleFieldId = randomStringId$2();
    const [wasInitialized, setWasInitialized] = hooks.useState(false);
    const modalPlugin = $app.config.plugins
        .eventModal;
    const dateTimeSeparator = ' ';
    const [isFullDayEvent, setIsFullDayEvent] = hooks.useState(dateStringRegex.test(modalPlugin.formValues.value.start));
    const [startDate, setStartDate] = hooks.useState(modalPlugin.formValues.value.start
        ? toDateString$2(toJSDate$1(modalPlugin.formValues.value.start))
        : '');
    const [startTime, setStartTime] = hooks.useState(modalPlugin.formValues.value.start
        ? toTimeString$1(toJSDate$1(modalPlugin.formValues.value.start))
        : '');
    const [endDate, setEndDate] = hooks.useState(modalPlugin.formValues.value.end
        ? toDateString$2(toJSDate$1(modalPlugin.formValues.value.end))
        : '');
    const [endTime, setEndTime] = hooks.useState(modalPlugin.formValues.value.end
        ? toTimeString$1(toJSDate$1(modalPlugin.formValues.value.end))
        : '');
    /**
     * Used for rrule dropdown n1 with normal frequencies + "custom" option
     * */
    const [rruleFreq, setRruleFreq] = hooks.useState(() => getInitialFrequencyIncludingCustomOption(modalPlugin, $app).value);
    /**
     * Used for the frequency value of the custom rrule section
     * */
    const [customRRuleFreq, setCustomRRuleFreq] = hooks.useState(() => getInitialCustomRRuleFrequency(modalPlugin, $app).value);
    const [rruleUntil, setRruleUntil] = hooks.useState(() => getInitialRruleUntil(modalPlugin));
    const [rruleCount, setRruleCount] = hooks.useState(() => getInitialRruleCount(modalPlugin));
    const [rruleInterval, setRruleInterval] = hooks.useState(() => getInitialRruleInterval(modalPlugin));
    const [rruleEndsType, setRruleEndsType] = hooks.useState(() => {
        var _a, _b;
        if ((_a = modalPlugin.formValues.value.rrule) === null || _a === void 0 ? void 0 : _a.includes('COUNT'))
            return 'count';
        if ((_b = modalPlugin.formValues.value.rrule) === null || _b === void 0 ? void 0 : _b.includes('UNTIL'))
            return 'until';
        return 'never';
    });
    const [rruleByday, setRruleByday] = hooks.useState(() => getInitialRruleByDay(modalPlugin));
    const handleClickOnRruleWeekdaySelector = (day) => {
        if (!rruleByday) {
            setRruleByday([day]);
        }
        else {
            if (rruleByday.includes(day)) {
                setRruleByday(rruleByday.filter((d) => d !== day));
            }
            else {
                setRruleByday([...rruleByday, day]);
            }
        }
    };
    const updateByDay = (newFrequency) => {
        if (newFrequency !== 'WEEKLY') {
            setRruleByday(undefined);
        }
        else if (!rruleByday) {
            const startWeekday = toJSDate$1(modalPlugin.formValues.value.start).getDay();
            setRruleByday([rruleWeekdays[startWeekday]]);
        }
    };
    hooks.useEffect(() => {
        modalPlugin.formValues.value.start = isFullDayEvent
            ? startDate
            : startDate + dateTimeSeparator + startTime;
        if (startDate > endDate) {
            setEndDate(startDate);
        }
        if (startTime > endTime && startDate === endDate) {
            setEndTime(startTime);
        }
        if (wasInitialized && modalPlugin.config.onStartUpdate) {
            modalPlugin.config.onStartUpdate(modalPlugin.formValues.value.start);
        }
        setWasInitialized(true);
    }, [startDate, startTime, isFullDayEvent]);
    hooks.useEffect(() => {
        modalPlugin.formValues.value.end = isFullDayEvent
            ? endDate
            : endDate + dateTimeSeparator + endTime;
        if (endDate < startDate) {
            setStartDate(endDate);
        }
        if (endTime < startTime && startDate === endDate) {
            setStartTime(endTime);
        }
        if (rruleUntil && rruleUntil < endDate) {
            setRruleUntil(endDate);
        }
        if (wasInitialized && modalPlugin.config.onEndUpdate) {
            modalPlugin.config.onEndUpdate(modalPlugin.formValues.value.end);
        }
        setWasInitialized(true);
    }, [endDate, endTime, isFullDayEvent]);
    hooks.useEffect(() => {
        Object.values(modalPlugin.formValidationErrors).forEach((error) => {
            error.value = undefined;
        });
    }, []);
    const [shouldValidate, setShouldValidate] = hooks.useState(false);
    const SAVE_BUTTON_BASE_CLASS = 'sx__app-button-filled';
    const [saveButtonClasses, setSaveButtonClasses] = hooks.useState([
        SAVE_BUTTON_BASE_CLASS,
    ]);
    const validate = () => {
        Object.entries({
            ...modalPlugin.config.fields,
            ...modalPlugin.config.customFields,
        }).forEach(([fieldName, field]) => {
            // unwrap custom fields since they are signals
            if ('value' in field)
                field = field.value;
            if (!('validator' in field) || !field.validator)
                return;
            const validationResult = field.validator(modalPlugin.formValues.value[fieldName]);
            if (!validationResult.isValid && fieldName) {
                modalPlugin.formValidationErrors[fieldName].value =
                    validationResult.message;
            }
            else {
                modalPlugin.formValidationErrors[fieldName].value = undefined;
            }
        });
    };
    const validateIfShouldValidate = () => {
        if (shouldValidate)
            validate();
    };
    const isFormValid = () => {
        return Object.values(modalPlugin.formValidationErrors).every((error) => !error.value);
    };
    const updateExistingEvent = () => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const eventId = ((_a = modalPlugin.calendarEvent.value) === null || _a === void 0 ? void 0 : _a.id) || '';
        const eventToUpdate = modalPlugin.eventsService.get(eventId);
        if (!eventToUpdate)
            throw new Error('Did not find event with ID ' + ((_b = modalPlugin.calendarEvent.value) === null || _b === void 0 ? void 0 : _b.id));
        const updatedEvent = {
            ...eventToUpdate,
            ...modalPlugin.formValues.value,
            end: modalPlugin.formValues.value.end || modalPlugin.formValues.value.start,
            id: eventToUpdate.id,
        };
        // for edit_added mode
        if ((_d = (_c = updatedEvent._options) === null || _c === void 0 ? void 0 : _c.additionalClasses) === null || _d === void 0 ? void 0 : _d.includes(ADDED_EVENT_CLASS_NAME)) {
            updatedEvent._options.additionalClasses =
                updatedEvent._options.additionalClasses.filter((className) => className !== ADDED_EVENT_CLASS_NAME);
        }
        modalPlugin.eventsService.update(updatedEvent);
        modalPlugin.close();
        if (modalPlugin.modalState.value === 'edit_added') {
            (_f = (_e = modalPlugin.config).onAddEvent) === null || _f === void 0 ? void 0 : _f.call(_e, updatedEvent);
        }
        else {
            (_h = (_g = $app.config.callbacks) === null || _g === void 0 ? void 0 : _g.onEventUpdate) === null || _h === void 0 ? void 0 : _h.call(_g, updatedEvent);
        }
    };
    const createNewEvent = () => {
        var _a;
        if (!modalPlugin.config.onAddEvent)
            return;
        const newEvent = {
            id: ((_a = modalPlugin.calendarEvent.value) === null || _a === void 0 ? void 0 : _a.id) || '',
            title: modalPlugin.formValues.value.title,
            description: modalPlugin.formValues.value.description,
            start: modalPlugin.formValues.value.start,
            end: modalPlugin.formValues.value.end,
            people: modalPlugin.formValues.value.people,
            calendarId: modalPlugin.formValues.value.calendarId,
            rrule: modalPlugin.formValues.value.rrule,
            resourceId: modalPlugin.formValues.value.resourceId,
        };
        modalPlugin.eventsService.add(newEvent);
        modalPlugin.close();
        modalPlugin.config.onAddEvent(newEvent);
    };
    const setRrule = () => {
        if (!rruleFreq) {
            modalPlugin.formValues.value.rrule = undefined;
            return;
        }
        const frequencyPart = rruleFreq !== 'custom' ? rruleFreq : customRRuleFreq;
        const rruleParts = ['FREQ=' + frequencyPart];
        const customRrule = rruleFreq === 'custom';
        if (customRrule && rruleInterval)
            rruleParts.push('INTERVAL=' + rruleInterval);
        if (customRrule && rruleEndsType === 'until' && rruleUntil)
            rruleParts.push('UNTIL=' + toICalendarDateTimeWithEndOfDay(rruleUntil));
        if (customRrule && rruleEndsType === 'count' && rruleCount)
            rruleParts.push('COUNT=' + rruleCount);
        if (customRrule && rruleByday && rruleByday.length > 0)
            rruleParts.push('BYDAY=' + rruleByday.join(','));
        // https://datatracker.ietf.org/doc/html/rfc5545 pages 42-43
        if (customRRuleFreq.includes('WEEKLY') &&
            rruleInterval &&
            rruleInterval !== 1 &&
            (rruleByday === null || rruleByday === void 0 ? void 0 : rruleByday.length)) {
            rruleParts.push(`WKST=${getWkstFromConfig($app.config)}`);
        }
        modalPlugin.formValues.value.rrule = rruleParts.join(';');
    };
    const saveEvent = () => {
        setRrule();
        setShouldValidate(true);
        validate();
        if (!isFormValid()) {
            setSaveButtonClasses([SAVE_BUTTON_BASE_CLASS, 'has-shake-animation']);
            setTimeout(() => {
                setSaveButtonClasses([SAVE_BUTTON_BASE_CLASS]);
            }, 500);
            return;
        }
        if (['edit', 'edit_added'].includes(modalPlugin.modalState.value))
            updateExistingEvent();
        else
            createNewEvent();
    };
    const cancel = () => {
        if (modalPlugin.modalState.value === 'edit')
            return (modalPlugin.modalState.value = 'view');
        if (modalPlugin.modalState.value === 'edit_added')
            removeEditAddedEvent();
        modalPlugin.close();
    };
    const getCalendars = () => {
        return Object.entries($app.config.calendars.value).map(([key, value]) => {
            return { label: value.label || '', value: key };
        });
    };
    const getSelectedCalendarOrUndefined = () => {
        const selectedCalendar = $app.config.calendars.value[modalPlugin.formValues.value.calendarId];
        if (!selectedCalendar)
            return undefined;
        return selectedCalendar
            ? {
                label: selectedCalendar.label || '',
                value: modalPlugin.formValues.value.calendarId,
            }
            : undefined;
    };
    const configuredFields = modalPlugin.config.fields;
    const hasConfiguredFields = !!configuredFields;
    const hasConfiguredAllDateTimeFields = hasConfiguredFields &&
        configuredFields.startDate &&
        configuredFields.startTime &&
        configuredFields.endDate &&
        configuredFields.endTime;
    const isAddMode = modalPlugin.modalState.value === 'add';
    const isEditAddedMode = modalPlugin.modalState.value === 'edit_added';
    const showDescription = !hasConfiguredFields || configuredFields.description;
    const showDateTimeFields = isAddMode ||
        isEditAddedMode ||
        !hasConfiguredFields ||
        hasConfiguredAllDateTimeFields;
    const showCalendarField = !hasConfiguredFields ||
        (configuredFields.calendarId &&
            Object.entries(((_a = $app.config) === null || _a === void 0 ? void 0 : _a.calendars) || {}).length > 1);
    const showResourceField = !hasConfiguredFields || configuredFields.resourceId;
    const showRruleFields = !hasConfiguredFields ||
        (configuredFields &&
            configuredFields.rruleFrequency &&
            configuredFields.rruleUntil &&
            configuredFields.rruleCustomFrequency &&
            configuredFields.rruleInterval &&
            configuredFields.rruleCount &&
            configuredFields.rruleByDay);
    hooks.useEffect(() => {
        var _a;
        const titleField = document.getElementById(titleFieldId);
        if (titleField) {
            (_a = window.getSelection()) === null || _a === void 0 ? void 0 : _a.empty();
            setTimeout(() => {
                titleField.focus();
            }, 10);
        }
    }, []);
    const [isInHiddenCalendar, setIsInHiddenCalendar] = hooks.useState(false);
    const checkIsInHiddenCalendar = () => {
        if (!$app.calendarEvents.filterPredicate.value)
            return;
        const isInHiddenCalendar = [modalPlugin.formValues.value].filter($app.calendarEvents.filterPredicate.value).length === 0;
        setIsInHiddenCalendar(isInHiddenCalendar);
    };
    hooks.useEffect(() => {
        checkIsInHiddenCalendar();
    }, []);
    const resources = 'resourceViewConfig' in $app
        ? $app.resourceViewConfig.resources.value
        : [];
    const getResourceItems = () => {
        return resources.map((resource) => {
            return { label: resource.label || '', value: resource.id };
        });
    };
    const getSelectedResourceOrUndefined = () => {
        const selectedResource = resources.find((resource) => resource.id === modalPlugin.formValues.value.resourceId);
        if (!selectedResource)
            return undefined;
        return {
            label: selectedResource.label || '',
            value: selectedResource.id,
        };
    };
    const isRtl = ((_b = document.querySelector('html')) === null || _b === void 0 ? void 0 : _b.getAttribute('dir')) === 'rtl';
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { className: "sx__event-form", children: [modalPlugin.isEditingRecurringEvent.value && (jsxRuntime.jsxs("div", { className: "sx__event-form-alert sx__event-form-recurrence-warning", children: [jsxRuntime.jsx(WarningSign, {}), $app.translate('You are editing the first in a series of recurring events.')] })), isInHiddenCalendar && (jsxRuntime.jsxs("div", { className: "sx__event-form-alert sx__event-form-info-box", children: [jsxRuntime.jsx(InfoIcon, {}), $app.translate('This event is in a hidden calendar.')] })), true !== modalPlugin.config.hideTitle && (jsxRuntime.jsx(TextField, { id: titleFieldId, initialValue: modalPlugin.formValues.value.title || '', onChange: (value) => {
                        var _a, _b, _c;
                        (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.title) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                        modalPlugin.formValues.value.title = value;
                        validateIfShouldValidate();
                    }, label: ((_d = (_c = modalPlugin.config.fields) === null || _c === void 0 ? void 0 : _c.title) === null || _d === void 0 ? void 0 : _d.label) || $app.translate('Title'), fieldName: ((_f = (_e = modalPlugin.config.fields) === null || _e === void 0 ? void 0 : _e.title) === null || _f === void 0 ? void 0 : _f.name) || 'title', errorMessage: (_g = modalPlugin.formValidationErrors.title) === null || _g === void 0 ? void 0 : _g.value, placeholder: (_j = (_h = modalPlugin.config.fields) === null || _h === void 0 ? void 0 : _h.title) === null || _j === void 0 ? void 0 : _j.placeholder }, modalPlugin.formValues.value)), showDateTimeFields && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs("div", { className: "sx__event-time-input", children: [jsxRuntime.jsxs("div", { class: "sx__date-time-picker sx__date-time-start", children: [jsxRuntime.jsx(DatePicker, { label: ((_l = (_k = modalPlugin.config.fields) === null || _k === void 0 ? void 0 : _k.startDate) === null || _l === void 0 ? void 0 : _l.label) ||
                                                $app.translate('Start date'), placement: isRtl ? 'bottom-end' : 'bottom-start', name: ((_o = (_m = modalPlugin.config.fields) === null || _m === void 0 ? void 0 : _m.startDate) === null || _o === void 0 ? void 0 : _o.name) || 'start-date', onChange: (newStartDate) => {
                                                var _a, _b, _c;
                                                (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.startDate) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, newStartDate);
                                                setStartDate(newStartDate);
                                            }, min: (_p = modalPlugin.config.datePicker) === null || _p === void 0 ? void 0 : _p.min, max: (_q = modalPlugin.config.datePicker) === null || _q === void 0 ? void 0 : _q.max, initialValue: startDate, isDarkMode: $app.calendarState.isDark.value, locale: $app.config.locale.value }), !isFullDayEvent && (jsxRuntime.jsx(TimePicker, { "$app": $app, onChange: (newStartTime) => {
                                                var _a, _b, _c;
                                                (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.startTime) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, newStartTime);
                                                setStartTime(newStartTime);
                                            }, label: ((_s = (_r = modalPlugin.config.fields) === null || _r === void 0 ? void 0 : _r.startTime) === null || _s === void 0 ? void 0 : _s.label) ||
                                                $app.translate(''), name: ((_u = (_t = modalPlugin.config.fields) === null || _t === void 0 ? void 0 : _t.startTime) === null || _u === void 0 ? void 0 : _u.name) || 'start-time', initialValue: startTime, placement: $app.calendarState.isCalendarSmall.value || isRtl
                                                ? 'bottom-end'
                                                : 'bottom-start', isDarkMode: $app.calendarState.isDark.value, is12Hour: modalPlugin.config.has12HourTimeFormat || false }))] }), jsxRuntime.jsx("span", { className: 'sx__date-time-until', children: "until" }), jsxRuntime.jsxs("div", { class: "sx__date-time-picker sx__date-time-end", children: [jsxRuntime.jsx(DatePicker, { label: ((_w = (_v = modalPlugin.config.fields) === null || _v === void 0 ? void 0 : _v.endDate) === null || _w === void 0 ? void 0 : _w.label) ||
                                                $app.translate('End date'), placement: isRtl ? 'bottom-start' : 'bottom-end', name: ((_y = (_x = modalPlugin.config.fields) === null || _x === void 0 ? void 0 : _x.endDate) === null || _y === void 0 ? void 0 : _y.name) || 'end-date', onChange: (newEndDate) => {
                                                var _a, _b, _c;
                                                (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.endDate) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, newEndDate);
                                                setEndDate(newEndDate);
                                            }, initialValue: endDate, isDarkMode: $app.calendarState.isDark.value, min: (_z = modalPlugin.config.datePicker) === null || _z === void 0 ? void 0 : _z.min, max: (_0 = modalPlugin.config.datePicker) === null || _0 === void 0 ? void 0 : _0.max, locale: $app.config.locale.value }), !isFullDayEvent && (jsxRuntime.jsx(TimePicker, { "$app": $app, onChange: (newEndTime) => {
                                                var _a, _b, _c;
                                                (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.endTime) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, newEndTime);
                                                setEndTime(newEndTime);
                                            }, label: ((_2 = (_1 = modalPlugin.config.fields) === null || _1 === void 0 ? void 0 : _1.endTime) === null || _2 === void 0 ? void 0 : _2.label) ||
                                                $app.translate(''), initialValue: endTime, placement: isRtl ? 'bottom-start' : 'bottom-end', isDarkMode: $app.calendarState.isDark.value, name: ((_4 = (_3 = modalPlugin.config.fields) === null || _3 === void 0 ? void 0 : _3.endTime) === null || _4 === void 0 ? void 0 : _4.name) || 'end-time', is12Hour: modalPlugin.config.has12HourTimeFormat || false }))] })] }), jsxRuntime.jsx(AppCheckbox, { label: $app.translate('Full-day event'), initialValue: isFullDayEvent, onChange: (isChecked) => setIsFullDayEvent(isChecked) })] })), showRruleFields && (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { className: 'sx__rrule-wrapper', children: [jsxRuntime.jsx(AppSelect, { items: getFrequenciesIncludingNoneAndCustom($app), initialSelectedItem: getInitialFrequencyIncludingCustomOption(modalPlugin, $app), label: $app.translate('Frequency'), onChange: (value) => {
                                    setRruleFreq(value);
                                }, name: 'rrule', isDarkMode: $app.calendarState.isDark.value }), rruleFreq === 'custom' && (jsxRuntime.jsxs("section", { className: 'sx__custom-rrule', children: ["Repeat every \u00A0", jsxRuntime.jsx("div", { className: 'sx__form-field', children: jsxRuntime.jsx("div", { class: 'sx__text-field-wrapper', children: jsxRuntime.jsx("input", { className: 'sx__number-field-input', value: rruleInterval, type: "number", min: 1, max: 1000000, onChange: (e) => {
                                                    const value = parseInt(e.currentTarget.value);
                                                    setRruleInterval(value);
                                                    setRrule();
                                                } }) }) }), "\u00A0 \u00A0", jsxRuntime.jsx(AppSelect, { items: rruleInterval === 1
                                            ? getRealRruleFrequenciesSingular($app)
                                            : getRealRruleFrequenciesPlural($app), initialSelectedItem: getInitialCustomRRuleFrequency(modalPlugin, $app), label: $app.translate(' '), isDarkMode: $app.calendarState.isDark.value, onChange: (value) => {
                                            updateByDay(value);
                                            setCustomRRuleFreq(value);
                                            setRrule();
                                        }, name: 'rruleFrequency' }, rruleInterval), rruleByday && (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx(WeekdaySelector, { activeDays: rruleByday, onDayClick: handleClickOnRruleWeekdaySelector }) })), jsxRuntime.jsxs("div", { className: 'sx__rrule-ends', children: [jsxRuntime.jsx("h3", { children: "Ends" }), jsxRuntime.jsx("span", {}), jsxRuntime.jsxs("div", { className: 'sx__radio', children: [jsxRuntime.jsx("input", { className: 'sx__radio-input', type: "radio", id: "rrule-never", name: "rrule-ends", value: "never", checked: rruleEndsType === 'never', onChange: () => setRruleEndsType('never') }), jsxRuntime.jsx("label", { className: 'sx__radio-label', htmlFor: "rrule-never", children: "Never" })] }), jsxRuntime.jsx("span", {}), jsxRuntime.jsxs("div", { className: 'sx__radio', children: [jsxRuntime.jsx("input", { className: 'sx__radio-input', type: "radio", id: "rrule-count", name: "rrule-ends", value: "count", checked: rruleEndsType === 'count', onChange: () => setRruleEndsType('count') }), jsxRuntime.jsx("label", { className: 'sx__radio-label', htmlFor: "rrule-count", children: "After" })] }), jsxRuntime.jsxs("div", { children: [jsxRuntime.jsx("div", { className: 'sx__form-field', children: jsxRuntime.jsx("div", { class: 'sx__text-field-wrapper', children: jsxRuntime.jsx("input", { className: 'sx__number-field-input', disabled: rruleEndsType !== 'count', type: "number", min: 1, max: 1000000, value: rruleCount, onChange: (e) => {
                                                                    const value = parseInt(e.currentTarget.value);
                                                                    setRruleCount(value);
                                                                } }) }) }), "\u00A0 occassions"] }), jsxRuntime.jsxs("div", { className: 'sx__radio', children: [jsxRuntime.jsx("input", { className: 'sx__radio-input', type: "radio", id: "rrule-until", name: "rrule-ends", value: "until", checked: rruleEndsType === 'until', onChange: () => setRruleEndsType('until') }), jsxRuntime.jsx("label", { className: 'sx__radio-label', htmlFor: "rrule-until", children: "On" })] }), jsxRuntime.jsx(DatePicker, { initialValue: rruleUntil, onChange: (newDate) => {
                                                    setRruleUntil(newDate);
                                                }, isDarkMode: $app.calendarState.isDark.value, disabled: rruleEndsType !== 'until', width: '', name: 'until', label: ' ', min: (_5 = modalPlugin.config.datePicker) === null || _5 === void 0 ? void 0 : _5.min, max: (_6 = modalPlugin.config.datePicker) === null || _6 === void 0 ? void 0 : _6.max, locale: $app.config.locale.value })] })] }))] }) })), showDescription && (jsxRuntime.jsx(Textarea, { initialValue: modalPlugin.formValues.value.description || '', onChange: (value) => {
                        var _a, _b, _c;
                        (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.description) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                        modalPlugin.formValues.value.description = value;
                        validateIfShouldValidate();
                    }, placeholder: (_8 = (_7 = modalPlugin.config.fields) === null || _7 === void 0 ? void 0 : _7.description) === null || _8 === void 0 ? void 0 : _8.placeholder, label: ((_10 = (_9 = modalPlugin.config.fields) === null || _9 === void 0 ? void 0 : _9.description) === null || _10 === void 0 ? void 0 : _10.label) ||
                        $app.translate('Description'), name: ((_12 = (_11 = modalPlugin.config.fields) === null || _11 === void 0 ? void 0 : _11.description) === null || _12 === void 0 ? void 0 : _12.name) || 'description', errorMessage: (_13 = modalPlugin.formValidationErrors.description) === null || _13 === void 0 ? void 0 : _13.value }, modalPlugin.formValues.value + 'description')), modalPlugin.config.availablePeople && (jsxRuntime.jsx(AppCombobox, { items: modalPlugin.config.availablePeople, initialSelectedItems: modalPlugin.formValues.value.people, onChange: (value) => {
                        var _a, _b, _c;
                        (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.people) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                        modalPlugin.formValues.value.people = value;
                        validateIfShouldValidate();
                    }, placeholder: (_15 = (_14 = modalPlugin.config.fields) === null || _14 === void 0 ? void 0 : _14.people) === null || _15 === void 0 ? void 0 : _15.placeholder, label: ((_17 = (_16 = modalPlugin.config.fields) === null || _16 === void 0 ? void 0 : _16.people) === null || _17 === void 0 ? void 0 : _17.label) ||
                        $app.translate('People'), name: ((_19 = (_18 = modalPlugin.config.fields) === null || _18 === void 0 ? void 0 : _18.people) === null || _19 === void 0 ? void 0 : _19.name) || 'people', isDarkMode: $app.calendarState.isDark.value, errorMessage: (_20 = modalPlugin.formValidationErrors.people) === null || _20 === void 0 ? void 0 : _20.value }, modalPlugin.formValues.value + 'people')), showCalendarField && (jsxRuntime.jsx(AppComboboxSingleValue, { items: getCalendars(), initialSelectedItem: getSelectedCalendarOrUndefined(), label: ((_22 = (_21 = modalPlugin.config.fields) === null || _21 === void 0 ? void 0 : _21.calendarId) === null || _22 === void 0 ? void 0 : _22.label) ||
                        $app.translate('Calendar'), onChange: (value) => {
                        var _a, _b, _c;
                        (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.calendarId) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                        modalPlugin.formValues.value.calendarId = value;
                        validateIfShouldValidate();
                        checkIsInHiddenCalendar();
                    }, placeholder: (_24 = (_23 = modalPlugin.config.fields) === null || _23 === void 0 ? void 0 : _23.calendarId) === null || _24 === void 0 ? void 0 : _24.placeholder, name: ((_26 = (_25 = modalPlugin.config.fields) === null || _25 === void 0 ? void 0 : _25.calendarId) === null || _26 === void 0 ? void 0 : _26.name) || 'calendar', isDarkMode: $app.calendarState.isDark.value, errorMessage: (_27 = modalPlugin.formValidationErrors.calendarId) === null || _27 === void 0 ? void 0 : _27.value }, modalPlugin.formValues.value + 'calendar')), showResourceField && (jsxRuntime.jsx(AppComboboxSingleValue, { items: getResourceItems(), initialSelectedItem: getSelectedResourceOrUndefined(), label: ((_29 = (_28 = modalPlugin.config.fields) === null || _28 === void 0 ? void 0 : _28.resourceId) === null || _29 === void 0 ? void 0 : _29.label) ||
                        $app.translate('Resource'), placeholder: (_31 = (_30 = modalPlugin.config.fields) === null || _30 === void 0 ? void 0 : _30.resourceId) === null || _31 === void 0 ? void 0 : _31.placeholder, onChange: (value) => {
                        var _a, _b, _c;
                        (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.resourceId) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                        modalPlugin.formValues.value.resourceId = value;
                        validateIfShouldValidate();
                    }, name: ((_33 = (_32 = modalPlugin.config.fields) === null || _32 === void 0 ? void 0 : _32.resourceId) === null || _33 === void 0 ? void 0 : _33.name) || 'resource', isDarkMode: $app.calendarState.isDark.value, errorMessage: (_34 = modalPlugin.formValidationErrors.resourceId) === null || _34 === void 0 ? void 0 : _34.value }, modalPlugin.formValues.value + 'resource')), modalPlugin.config.customFields && (jsxRuntime.jsx(jsxRuntime.Fragment, { children: Object.entries(modalPlugin.config.customFields).map(([fieldName, field]) => {
                        var _a, _b, _c, _d, _e, _f, _g, _h;
                        return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [field.value.type === 'text' && (jsxRuntime.jsx(TextField, { id: fieldName, initialValue: modalPlugin.formValues.value[fieldName] || '', onChange: (value) => {
                                        var _a, _b;
                                        (_b = (_a = modalPlugin.config.customFields[fieldName].value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);
                                        modalPlugin.formValues.value[fieldName] = value;
                                        validateIfShouldValidate();
                                    }, placeholder: field.value.placeholder, label: field.value.label || '', fieldName: fieldName, errorMessage: (_a = modalPlugin.formValidationErrors[fieldName]) === null || _a === void 0 ? void 0 : _a.value }, field.value)), field.value.type == 'select' && (jsxRuntime.jsx(AppSelect, { items: field.value.items || [], label: field.value.label || '', onChange: (value) => {
                                        var _a, _b;
                                        (_b = (_a = modalPlugin.config.customFields[fieldName].value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);
                                        modalPlugin.formValues.value[fieldName] = value;
                                        validateIfShouldValidate();
                                    }, initialSelectedItem: ((_b = field.value.items) === null || _b === void 0 ? void 0 : _b.find((item) => {
                                        return (item.value ===
                                            modalPlugin.formValues.value[fieldName]);
                                    })) || undefined, name: fieldName }, field.value)), field.value.type === 'textarea' && (jsxRuntime.jsx(Textarea, { initialValue: modalPlugin.formValues.value[fieldName] || '', onChange: (value) => {
                                        var _a, _b;
                                        (_b = (_a = modalPlugin.config.customFields[fieldName].value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);
                                        modalPlugin.formValues.value[fieldName] = value;
                                        validateIfShouldValidate();
                                    }, placeholder: field.value.placeholder, label: field.value.label || '', name: fieldName, errorMessage: (_c = modalPlugin.formValidationErrors[fieldName]) === null || _c === void 0 ? void 0 : _c.value }, field.value)), field.value.type === 'combobox' && (jsxRuntime.jsx(AppComboboxSingleValue, { items: field.value.items || [], label: field.value.label || '', onChange: (value) => {
                                        var _a, _b;
                                        (_b = (_a = modalPlugin.config.customFields[fieldName].value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);
                                        modalPlugin.formValues.value[fieldName] = value;
                                        validateIfShouldValidate();
                                    }, initialSelectedItem: ((_d = field.value.items) === null || _d === void 0 ? void 0 : _d.find((item) => {
                                        return (item.value ===
                                            modalPlugin.formValues.value[fieldName]);
                                    })) || undefined, placeholder: field.value.placeholder, name: fieldName, errorMessage: (_e = modalPlugin.formValidationErrors[fieldName]) === null || _e === void 0 ? void 0 : _e.value }, field.value)), field.value.type === 'combobox-multi' && (jsxRuntime.jsx(AppCombobox, { items: ((_f = field.value.items) === null || _f === void 0 ? void 0 : _f.map((item) => item.label || '')) ||
                                        [], label: field.value.label || '', onChange: (value) => {
                                        var _a, _b;
                                        const valuesForSelectedLabels = value.map((label) => {
                                            var _a, _b;
                                            return (((_b = (_a = field.value.items) === null || _a === void 0 ? void 0 : _a.find((item) => item.label === label)) === null || _b === void 0 ? void 0 : _b.value) || '');
                                        });
                                        (_b = (_a = modalPlugin.config.customFields[fieldName].value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, valuesForSelectedLabels);
                                        modalPlugin.formValues.value[fieldName] =
                                            valuesForSelectedLabels;
                                        validateIfShouldValidate();
                                    }, initialSelectedItems: ((_g = modalPlugin.formValues.value[fieldName]) === null || _g === void 0 ? void 0 : _g.map((value) => {
                                        var _a, _b;
                                        return (((_b = (_a = field.value.items) === null || _a === void 0 ? void 0 : _a.find((item) => item.value === value)) === null || _b === void 0 ? void 0 : _b.label) || '');
                                    })) || [], placeholder: field.value.placeholder, name: fieldName, errorMessage: (_h = modalPlugin.formValidationErrors[fieldName]) === null || _h === void 0 ? void 0 : _h.value }, field.value)), field.value.type === 'any' &&
                                    field.value.InputComponent && (jsxRuntime.jsx(field.value.InputComponent, { initialValue: modalPlugin.formValues.value[fieldName] || '', onChange: (value) => {
                                        var _a, _b;
                                        (_b = (_a = modalPlugin.config.customFields[fieldName].value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);
                                        modalPlugin.formValues.value[fieldName] = value;
                                        validateIfShouldValidate();
                                    }, placeholder: field.value.placeholder, label: field.value.label || '', name: fieldName }, field.value))] }));
                    }) })), jsxRuntime.jsxs("div", { className: 'sx__form-actions', children: [jsxRuntime.jsx(AppButton, { onClick: saveEvent, additionalClasses: saveButtonClasses.join(' '), children: $app.translate('Save') }), jsxRuntime.jsx(AppButton, { onClick: cancel, additionalClasses: 'sx__app-button-outlined', children: $app.translate('Cancel') })] })] }) }));
}

function DeleteActions({ $app }) {
    const modalPlugin = $app.config.plugins
        .eventModal;
    return (jsxRuntime.jsxs("div", { children: [jsxRuntime.jsx("h2", { className: "sx__modal-delete-headline", children: $app.translate('Are you sure you want to delete this event?') }), jsxRuntime.jsxs("div", { className: "sx__modal-delete-actions", children: [jsxRuntime.jsx(AppButton, { additionalClasses: "sx__app-button-outlined", onClick: () => {
                            modalPlugin.modalState.value = 'view';
                        }, children: $app.translate('Cancel') }), jsxRuntime.jsx(AppButton, { additionalClasses: "sx__app-button-danger", onClick: () => {
                            var _a, _b;
                            const eventId = modalPlugin.calendarEvent.value.id;
                            modalPlugin.eventsService.remove(eventId);
                            modalPlugin.close();
                            (_b = (_a = modalPlugin.config).onDeleteEvent) === null || _b === void 0 ? void 0 : _b.call(_a, eventId);
                        }, children: $app.translate('Delete') })] })] }));
}

function InteractiveEventModal({ $app, }) {
    const [modalId] = hooks.useState(randomStringId$2());
    const { value: calendarEvent } = $app.config.plugins.eventModal.calendarEvent;
    const modalPlugin = $app.config.plugins
        .eventModal;
    const removeEditAddedEvent = () => {
        if (calendarEvent && modalPlugin.modalState.value === 'edit_added')
            modalPlugin.config.eventsService.remove(calendarEvent.id);
    };
    const clickOutsideListener = createClickOutsideListener($app, modalId, () => removeEditAddedEvent());
    const callSetPosition = () => {
        var _a, _b, _c;
        setPosition((_a = $app.elements.calendarWrapper) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect(), (_b = $app.config.plugins.eventModal) === null || _b === void 0 ? void 0 : _b.calendarEventDOMRect.value, ((_c = $app.elements.calendarWrapper) === null || _c === void 0 ? void 0 : _c.querySelector('.sx__interactive-event-modal')).clientHeight, modalPlugin.config.has12HourTimeFormat ? 595 : undefined);
    };
    const scrollListener = () => {
        var _a, _b;
        $app.config.plugins.eventModal.calendarEventDOMRect.value =
            (_b = (_a = $app.config.plugins.eventModal) === null || _a === void 0 ? void 0 : _a.calendarEventElement.value) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect();
        callSetPosition();
    };
    const escapeKeyDownListener = (e) => {
        setTimeout(() => {
            if (e.key === 'Escape' &&
                !window
                    .__sx_escapeKeyDownBlocker__) {
                modalPlugin.close();
                removeEditAddedEvent();
            }
        });
    };
    hooks.useEffect(() => {
        var _a;
        callSetPosition();
        modalPlugin.isOpen.value = true;
        document.addEventListener('click', clickOutsideListener, true);
        const scrollableAncestors = getScrollableParents(((_a = $app.config.plugins.eventModal) === null || _a === void 0 ? void 0 : _a.calendarEventElement.value) || null);
        scrollableAncestors.forEach((el) => el.addEventListener('scroll', scrollListener));
        document.addEventListener('keydown', escapeKeyDownListener);
        return () => {
            scrollableAncestors.forEach((el) => el.removeEventListener('scroll', scrollListener));
            document.removeEventListener('click', clickOutsideListener, true);
            document.removeEventListener('keydown', escapeKeyDownListener);
            modalPlugin.isOpen.value = false;
        };
    }, []);
    hooks.useEffect(() => {
        callSetPosition();
    }, [modalPlugin.modalState.value]);
    const startDrag = (e) => {
        const modal = document.getElementById(modalId);
        if (modal) {
            const modalRect = modal.getBoundingClientRect();
            const offsetX = e.clientX - modalRect.left;
            const offsetY = e.clientY - modalRect.top;
            const move = (e) => {
                modal.style.left = e.clientX - offsetX + 'px';
                modal.style.top = e.clientY - offsetY + 'px';
            };
            const stop = () => {
                document.removeEventListener('mousemove', move);
                document.removeEventListener('mouseup', stop);
            };
            document.addEventListener('mousemove', move);
            document.addEventListener('mouseup', stop);
        }
    };
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { id: modalId, "data-state": modalPlugin.modalState.value, className: `sx__interactive-event-modal${modalPlugin.isOpen.value ? ' is-open' : ''}`, children: [modalPlugin.config.movable && (jsxRuntime.jsx("div", { onMouseDown: startDrag, className: 'sx__interactive-event-modal__move-bar' })), calendarEvent && (jsxRuntime.jsxs(preact.Fragment, { children: [modalPlugin.modalState.value === 'view' && (jsxRuntime.jsx(EventDisplay, { "$app": $app, calendarEvent: calendarEvent })), ['edit', 'add', 'edit_added'].includes(modalPlugin.modalState.value) && (jsxRuntime.jsx(EventForm, { "$app": $app, removeEditAddedEvent: removeEditAddedEvent })), modalPlugin.modalState.value === 'delete' && (jsxRuntime.jsx(DeleteActions, { "$app": $app }))] }))] }) }));
}

const SX_INTERNAL_CALENDAR = '__SX-INTERNAL__';

const validateConfig = (config) => {
    if (!config.onAddEvent) {
        throw new Error('[Schedule-X error] onAddEvent callback must be configured in interactive event modal plugin');
    }
    const fields = config.fields;
    if ((fields === null || fields === void 0 ? void 0 : fields.startDate) ||
        (fields === null || fields === void 0 ? void 0 : fields.endDate) ||
        (fields === null || fields === void 0 ? void 0 : fields.startTime) ||
        (fields === null || fields === void 0 ? void 0 : fields.endTime)) {
        if (!fields.startDate ||
            !fields.endDate ||
            !fields.startTime ||
            !fields.endTime) {
            throw new Error('[Schedule-X error] startDate, startTime, endDate, and endTime must all be configured, if one of them is configured');
        }
    }
    if ((fields === null || fields === void 0 ? void 0 : fields.rruleFrequency) ||
        (fields === null || fields === void 0 ? void 0 : fields.rruleInterval) ||
        (fields === null || fields === void 0 ? void 0 : fields.rruleCount) ||
        (fields === null || fields === void 0 ? void 0 : fields.rruleUntil) ||
        (fields === null || fields === void 0 ? void 0 : fields.rruleByDay) ||
        (fields === null || fields === void 0 ? void 0 : fields.rruleCustomFrequency)) {
        if (!fields.rruleFrequency ||
            !fields.rruleInterval ||
            !fields.rruleCount ||
            !fields.rruleUntil ||
            !fields.rruleByDay ||
            !fields.rruleCustomFrequency) {
            throw new Error('[Schedule-X error] if one rrule field is configured, all of them must be configured. Please review the documentation.');
        }
    }
};

const createInteractiveEventModal = (config) => {
    validateConfig(config);
    const calendarEvent = signals.signal(null);
    const calendarEventDOMRect = signals.signal(null);
    const formValues = signals.signal({
        start: toDateTimeString(new Date()),
        end: toDateTimeString(new Date()),
        title: undefined,
        description: undefined,
        location: undefined,
        people: [],
        calendarId: undefined,
    });
    const modalState = signals.signal('view');
    const isEditingRecurringEvent = signals.signal(false);
    let _$app;
    const _setCalendarEventInViewMode = (event, eventTargetDOMRect) => {
        var _a;
        if (config.canOpenModal && !config.canOpenModal(event))
            return;
        const clickedOnEventInEditAddedMode = modalState.value === 'edit_added' && ((_a = calendarEvent.value) === null || _a === void 0 ? void 0 : _a.id);
        if (clickedOnEventInEditAddedMode) {
            config.eventsService.remove(calendarEvent.value.id);
        }
        modalState.value = 'view';
        calendarEvent.value = event;
        calendarEventDOMRect.value = eventTargetDOMRect;
    };
    const calendarEventElement = signals.signal(null);
    const _setCalendarEventInEditAddedMode = (event, eventTargetDOMRect) => {
        var _a;
        const eventElement = (_a = _$app === null || _$app === void 0 ? void 0 : _$app.elements.calendarWrapper) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-event-id="${event.id}"]`);
        if (eventElement instanceof HTMLElement) {
            calendarEventElement.value = eventElement;
        }
        modalState.value = 'edit_added';
        calendarEvent.value = event;
        calendarEventDOMRect.value = eventTargetDOMRect;
    };
    function clickToCreate(start, otherEventProperties = {}) {
        const eventId = otherEventProperties.id || randomStringId$2();
        const observer = new MutationObserver((mutations) => {
            // wait for an element with data-event-id="eventId" to be added to the DOM
            mutations.forEach((mutation) => {
                const target = mutation.target;
                const eventElement = target.dataset.eventId === String(eventId)
                    ? target
                    : target.querySelector(`[data-event-id="${eventId}"]`);
                const eventInternal = _$app === null || _$app === void 0 ? void 0 : _$app.calendarEvents.list.value.find((event) => event.id === eventId);
                if (eventElement && eventInternal) {
                    observer.disconnect();
                    const rect = eventElement.getBoundingClientRect();
                    _setCalendarEventInEditAddedMode(eventInternal, rect);
                    formValues.value = {
                        start: eventInternal.start,
                        end: eventInternal.end,
                        title: eventInternal.title,
                        description: eventInternal.description,
                        calendarId: eventInternal.calendarId !== SX_INTERNAL_CALENDAR
                            ? eventInternal.calendarId
                            : undefined,
                        people: eventInternal.people,
                    };
                    modalState.value = 'edit_added';
                }
            });
        });
        if (_$app) {
            observer.observe(_$app.elements.calendarWrapper || document, {
                childList: true,
                subtree: true,
            });
        }
        isEditingRecurringEvent.value = false;
        const _start = start;
        const end = /^\w{4}-\w{2}-\w{2}$/.test(_start)
            ? _start
            : addMinutes(_start, 60);
        const newEvent = {
            id: eventId,
            start: _start,
            end: end,
            calendarId: SX_INTERNAL_CALENDAR,
            _options: {
                additionalClasses: [ADDED_EVENT_CLASS_NAME],
            },
            ...otherEventProperties,
        };
        if (_$app.calendarEvents.filterPredicate.value) {
            const isInHiddenCalendar = [newEvent].filter(_$app.calendarEvents.filterPredicate.value).length === 0;
            if (isInHiddenCalendar)
                newEvent.calendarId = SX_INTERNAL_CALENDAR;
        }
        config.eventsService.add(newEvent);
    }
    const allFieldsWithValidators = [];
    Object.entries({
        ...config.fields,
    }).forEach(([fieldName, field]) => {
        if ('validator' in field && field.validator) {
            allFieldsWithValidators.push(fieldName);
        }
    });
    Object.entries({
        ...config.customFields,
    }).forEach(([fieldName, field]) => {
        if ('validator' in field.value && field.value.validator) {
            allFieldsWithValidators.push(fieldName);
        }
    });
    return definePlugin('eventModal', {
        config,
        calendarEventElement: calendarEventElement,
        name: 'eventModal',
        beforeRender($app) {
            _$app = $app;
        },
        calendarEvent,
        calendarEventDOMRect,
        ComponentFn: InteractiveEventModal,
        setCalendarEvent: _setCalendarEventInViewMode,
        formValues,
        formValidationErrors: allFieldsWithValidators.reduce((acc, fieldName) => {
            acc[fieldName] = signals.signal(undefined);
            return acc;
        }, {}),
        modalState,
        eventsService: config.eventsService,
        isEditingRecurringEvent,
        openEventCreationModal: (id, start, otherEventProperties = {}) => {
            isEditingRecurringEvent.value = false;
            modalState.value = 'add';
            const _start = start || toDateTimeString(new Date());
            const newEvent = {
                id: id,
                start: _start,
                end: addMinutes(_start, 60),
                title: '',
                description: '',
                people: [],
                ...otherEventProperties,
            };
            calendarEvent.value = newEvent;
            formValues.value = {
                start: newEvent.start,
                end: newEvent.end,
                title: newEvent.title,
                description: newEvent.description,
                people: newEvent.people,
            };
            calendarEventDOMRect.value = {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
            };
        },
        openForExistingEvent: (id) => {
            var _a;
            const event = _$app === null || _$app === void 0 ? void 0 : _$app.calendarEvents.list.value.find((event) => event.id === id);
            if (!event) {
                console.warn(`[Schedule-X error]: Tried to open modal for event with id ${id} but it was not found`);
                return;
            }
            const eventElement = (_a = _$app === null || _$app === void 0 ? void 0 : _$app.elements.calendarWrapper) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-event-id="${event.id}"]`);
            if (eventElement instanceof HTMLElement) {
                calendarEventElement.value = eventElement;
                const rect = eventElement.getBoundingClientRect();
                _setCalendarEventInViewMode(event, rect);
            }
            else {
                _setCalendarEventInViewMode(event, {});
            }
            formValues.value = {
                start: event.start,
                end: event.end,
                title: event.title,
                description: event.description,
                people: event.people,
            };
        },
        clickToCreate(start, otherEventProperties = {}) {
            clickToCreate(start, otherEventProperties);
        },
        close: () => {
            calendarEvent.value = null;
            calendarEventDOMRect.value = null;
        },
        isOpen: signals.signal(false),
        isEventEditable: config.isEventEditable,
    });
};

const translations = {
    enUS: {
        'Are you sure you want to delete this event?': 'Are you sure you want to delete this event?',
        Cancel: 'Cancel',
        Delete: 'Delete',
        'You are editing the first in a series of recurring events.': 'You are editing the first in a series of recurring events.',
        'This event is in a hidden calendar.': 'This event is in a hidden calendar.',
        Title: 'Title',
        'Start date': 'Start date',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'End date',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Full-day event',
        Frequency: 'Frequency',
        Until: 'Until',
        Description: 'Description',
        People: 'People',
        Calendar: 'Calendar',
        Resource: 'Resource',
        Save: 'Save',
        Once: 'Once',
        Daily: 'Daily',
        Weekly: 'Weekly',
        Monthly: 'Monthly',
        Yearly: 'Yearly',
    },
    deDE: {
        'Are you sure you want to delete this event?': 'Möchten Sie dieses Ereignis wirklich löschen?',
        Cancel: 'Abbrechen',
        Delete: 'Löschen',
        'You are editing the first in a series of recurring events.': 'Sie bearbeiten das erste in einer Serie von wiederkehrenden Ereignissen.',
        'This event is in a hidden calendar.': 'Dieses Ereignis befindet sich in einem ausgeblendeten Kalender.',
        Title: 'Titel',
        'Start date': 'Startdatum',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Enddatum',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Ganztägiges Ereignis',
        Frequency: 'Häufigkeit',
        Until: 'Bis',
        Description: 'Beschreibung',
        People: 'Personen',
        Calendar: 'Kalender',
        Resource: 'Ressource',
        Save: 'Speichern',
        Once: 'Einmalig',
        Daily: 'Täglich',
        Weekly: 'Wöchentlich',
        Monthly: 'Monatlich',
        Yearly: 'Jährlich',
    },
    srLatnRS: {
        'Are you sure you want to delete this event?': 'Da li ste sigurni da želite da obrišete ovaj događaj?',
        Cancel: 'Otkaži',
        Delete: 'Obriši',
        'You are editing the first in a series of recurring events.': 'Uređujete prvi u seriji ponavljajućih događaja.',
        'This event is in a hidden calendar.': 'Ovaj događaj je u skrivenom kalendaru.',
        Title: 'Naslov',
        'Start date': 'Datum početka',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Datum završetka',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Ceo dan',
        Frequency: 'Frekvencija',
        Until: 'Do',
        Description: 'Opis',
        People: 'Ljudi',
        Calendar: 'Kalendar',
        Resource: 'Resurs',
        Save: 'Sačuvaj',
        Once: 'Jednom',
        Daily: 'Dnevno',
        Weekly: 'Nedeljno',
        Monthly: 'Mesečno',
        Yearly: 'Godišnje',
    },
    enGB: {
        'Are you sure you want to delete this event?': 'Are you sure you want to delete this event?',
        Cancel: 'Cancel',
        Delete: 'Delete',
        'You are editing the first in a series of recurring events.': 'You are editing the first in a series of recurring events.',
        'This event is in a hidden calendar.': 'This event is in a hidden calendar.',
        Title: 'Title',
        'Start date': 'Start date',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'End date',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Full-day event',
        Frequency: 'Frequency',
        Until: 'Until',
        Description: 'Description',
        People: 'People',
        Calendar: 'Calendar',
        Resource: 'Resource',
        Save: 'Save',
        Once: 'Once',
        Daily: 'Daily',
        Weekly: 'Weekly',
        Monthly: 'Monthly',
        Yearly: 'Yearly',
    },
    ptBR: {
        'Are you sure you want to delete this event?': 'Tem certeza de que deseja excluir este evento?',
        Cancel: 'Cancelar',
        Delete: 'Excluir',
        'You are editing the first in a series of recurring events.': 'Você está editando o primeiro de uma série de eventos recorrentes.',
        'This event is in a hidden calendar.': 'Este evento está em um calendário oculto.',
        Title: 'Título',
        'Start date': 'Data de início',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Data de término',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Evento de dia inteiro',
        Frequency: 'Frequência',
        Until: 'Até',
        Description: 'Descrição',
        People: 'Pessoas',
        Calendar: 'Calendário',
        Resource: 'Recurso',
        Save: 'Salvar',
        Once: 'Uma vez',
        Daily: 'Diariamente',
        Weekly: 'Semanalmente',
        Monthly: 'Mensalmente',
        Yearly: 'Anualmente',
    },
    itIT: {
        'Are you sure you want to delete this event?': 'Sei sicuro di voler eliminare questo evento?',
        Cancel: 'Annulla',
        Delete: 'Elimina',
        'You are editing the first in a series of recurring events.': 'Stai modificando il primo di una serie di eventi ricorrenti.',
        'This event is in a hidden calendar.': 'Questo evento è in un calendario nascosto',
        Title: 'Titolo',
        'Start date': 'Data di inizio',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Data di fine',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': "Evento per l'intera giornata",
        Frequency: 'Frequenza',
        Until: 'Fino a',
        Description: 'Descrizione',
        People: 'Persone',
        Calendar: 'Calendario',
        Resource: 'Risorsa',
        Save: 'Salva',
        Once: 'Una volta',
        Daily: 'Giornalmente',
        Weekly: 'Settimanalmente',
        Monthly: 'Mensilmente',
        Yearly: 'Annualmente',
    },
    svSE: {
        'Are you sure you want to delete this event?': 'Är du säker på att du vill ta bort det här evenemanget?',
        Cancel: 'Avbryt',
        Delete: 'Ta bort',
        'You are editing the first in a series of recurring events.': 'Du redigerar det första i en serie återkommande händelser.',
        'This event is in a hidden calendar.': 'Detta evenemang är i en dold kalender',
        Title: 'Titel',
        'Start date': 'Startdatum',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Slutdatum',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Heldags evenemang',
        Frequency: 'Frekvens',
        Until: 'Tills',
        Description: 'Beskrivning',
        People: 'Deltagare',
        Calendar: 'Kalender',
        Resource: 'Resurs',
        Save: 'Spara',
        Once: 'En gång',
        Daily: 'Dagligen',
        Weekly: 'Veckovis',
        Monthly: 'Månadsvis',
        Yearly: 'Årligen',
    },
    zhCN: {
        'Are you sure you want to delete this event?': '您确定要删除此事件吗？',
        Cancel: '取消',
        Delete: '删除',
        'You are editing the first in a series of recurring events.': '您正在编辑一系列重复事件中的第一个。',
        'This event is in a hidden calendar.': '此事件在隐藏的日历中。',
        Title: '标题',
        'Start date': '开始日期',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': '结束日期',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': '全天事件',
        Frequency: '频率',
        Until: '直到',
        Description: '描述',
        People: '人员',
        Calendar: '日历',
        Resource: '资源',
        Save: '保存',
        Once: '一次',
        Daily: '每日',
        Weekly: '每周',
        Monthly: '每月',
        Yearly: '每年',
    },
    zhTW: {
        'Are you sure you want to delete this event?': '您確定要刪除此事件嗎？',
        Cancel: '取消',
        Delete: '刪除',
        'You are editing the first in a series of recurring events.': '您正在編輯一系列重複事件中的第一個。',
        'This event is in a hidden calendar.': '此事件在隱藏的日曆中。',
        Title: '標題',
        'Start date': '開始日期',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': '結束日期',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': '全天事件',
        Frequency: '頻率',
        Until: '直到',
        Description: '描述',
        People: '人員',
        Calendar: '日曆',
        Resource: '資源',
        Save: '保存',
        Once: '一次',
        Daily: '每日',
        Weekly: '每週',
        Monthly: '每月',
        Yearly: '每年',
    },
    jaJP: {
        'Are you sure you want to delete this event?': 'このイベントを削除してもよろしいですか？',
        Cancel: 'キャンセル',
        Delete: '削除',
        'You are editing the first in a series of recurring events.': '繰り返しイベントの最初を編集しています。',
        'This event is in a hidden calendar.': 'このイベントは非表示のカレンダーにあります。',
        Title: 'タイトル',
        'Start date': '開始日',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': '終了日',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': '終日イベント',
        Frequency: '頻度',
        Until: 'まで',
        Description: '説明',
        People: '参加者',
        Calendar: 'カレンダー',
        Resource: 'リソース',
        Save: '保存',
        Once: '一度',
        Daily: '毎日',
        Weekly: '毎週',
        Monthly: '毎月',
        Yearly: '毎年',
    },
    ruRU: {
        'Are you sure you want to delete this event?': 'Вы уверены, что хотите удалить это событие?',
        Cancel: 'Отмена',
        Delete: 'Удалит��',
        'You are editing the first in a series of recurring events.': 'Вы редактируете первое в серии повторяющихся событий.',
        'This event is in a hidden calendar.': 'Это событие находится в скрытом календаре.',
        Title: 'Название',
        'Start date': 'Дата начала',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Дата окончания',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Событие на весь день',
        Frequency: 'Частота',
        Until: 'До',
        Description: 'Описание',
        People: 'Участники',
        Calendar: 'Календарь',
        Resource: 'Ресурс',
        Save: 'Сохранить',
        Once: 'Один раз',
        Daily: 'Ежедневно',
        Weekly: 'Еженедельно',
        Monthly: 'Ежемесячно',
        Yearly: 'Ежегодно',
    },
    koKR: {
        'Are you sure you want to delete this event?': '이 이벤트를 삭제하시겠습니까?',
        Cancel: '취소',
        Delete: '삭제',
        'You are editing the first in a series of recurring events.': '반복되는 이벤트 중 첫 번째를 편집 중입니다.',
        'This event is in a hidden calendar.': '이 이벤트는 숨겨진 캘린더에 있습니다.',
        Title: '제목',
        'Start date': '시작 날짜',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': '종료 날짜',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': '종일 이벤트',
        Frequency: '빈도',
        Until: '까지',
        Description: '설명',
        People: '참여자',
        Calendar: '캘린더',
        Resource: '자원',
        Save: '저장',
        Once: '한 번',
        Daily: '매일',
        Weekly: '매주',
        Monthly: '매월',
        Yearly: '매년',
    },
    frFR: {
        'Are you sure you want to delete this event?': 'Voulez-vous vraiment supprimer cet événement ?',
        Cancel: 'Annuler',
        Delete: 'Supprimer',
        'You are editing the first in a series of recurring events.': "Vous modifiez le premier d'une série d'événements récurrents.",
        'This event is in a hidden calendar.': 'Cet événement est dans un calendrier masqué.',
        Title: 'Titre',
        'Start date': 'Date de début',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Date de fin',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Événement sur toute la journée',
        Frequency: 'Fréquence',
        Until: "Jusqu'à",
        Description: 'Description',
        People: 'Personnes',
        Calendar: 'Calendrier',
        Resource: 'Ressource',
        Save: 'Enregistrer',
        Once: 'Une fois',
        Daily: 'Quotidien',
        Weekly: 'Hebdomadaire',
        Monthly: 'Mensuel',
        Yearly: 'Annuel',
    },
    daDK: {
        'Are you sure you want to delete this event?': 'Er du sikker på, at du vil slette dette arrangement?',
        Cancel: 'Annuller',
        Delete: 'Slet',
        'You are editing the first in a series of recurring events.': 'Du redigerer den første i en serie af gentagne begivenheder.',
        'This event is in a hidden calendar.': 'Denne begivenhed er i en skjult kalender',
        Title: 'Titel',
        'Start date': 'Startdato',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Slutdato',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Hele dagen begivenhed',
        Frequency: 'Frekvens',
        Until: 'Indtil',
        Description: 'Beskrivelse',
        People: 'Personer',
        Calendar: 'Kalender',
        Resource: 'Ressource',
        Save: 'Gem',
        Once: 'En gang',
        Daily: 'Daglig',
        Weekly: 'Ugentlig',
        Monthly: 'Månedlig',
        Yearly: 'Årlig',
    },
    mkMK: {
        'Are you sure you want to delete this event?': 'Дали сте сигурни дека сакате да го избришете овој настан?',
        Cancel: 'Откажи',
        Delete: 'Избриши',
        'You are editing the first in a series of recurring events.': 'Го уредувате првиот во серијата на повторувачки настани.',
        'This event is in a hidden calendar.': 'Овој настан е во скриен календар.',
        Title: 'Наслов',
        'Start date': 'Почетен датум',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Краен датум',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Целодневен настан',
        Frequency: 'Честота',
        Until: 'До',
        Description: 'Опис',
        People: 'Луѓе',
        Calendar: 'Календар',
        Resource: 'Ресурс',
        Save: 'Зачувај',
        Once: 'Еднаш',
        Daily: 'Дневно',
        Weekly: 'Неделно',
        Monthly: 'Месечно',
        Yearly: 'Годишно',
    },
    plPL: {
        'Are you sure you want to delete this event?': 'Czy na pewno chcesz usunąć to wydarzenie?',
        Cancel: 'Anuluj',
        Delete: 'Usuń',
        'You are editing the first in a series of recurring events.': 'Edytujesz pierwszy z serii cyklicznych wydarzeń.',
        'This event is in a hidden calendar.': 'To wydarzenie znajduje się w ukrytym kalendarzu.',
        Title: 'Tytuł',
        'Start date': 'Data rozpoczęcia',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Data zakończenia',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Wydarzenie całodniowe',
        Frequency: 'Częstotliwość',
        Until: 'Do',
        Description: 'Opis',
        People: 'Osoby',
        Calendar: 'Kalendarz',
        Resource: 'Zasób',
        Save: 'Zapisz',
        Once: 'Raz',
        Daily: 'Codziennie',
        Weekly: 'Co tydzień',
        Monthly: 'Co miesiąc',
        Yearly: 'Rocznie',
    },
    esES: {
        'Are you sure you want to delete this event?': '¿Estás seguro de que quieres eliminar este evento?',
        Cancel: 'Cancelar',
        Delete: 'Eliminar',
        'You are editing the first in a series of recurring events.': 'Estás editando el primero de una serie de eventos recurrentes.',
        'This event is in a hidden calendar.': 'Este evento está en un calendario oculto.',
        Title: 'Título',
        'Start date': 'Fecha de inicio',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Fecha de finalización',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Evento de todo el día',
        Frequency: 'Frecuencia',
        Until: 'Hasta',
        Description: 'Descripción',
        People: 'Personas',
        Calendar: 'Calendario',
        Resource: 'Recurso',
        Save: 'Guardar',
        Once: 'Una vez',
        Daily: 'Diariamente',
        Weekly: 'Semanalmente',
        Monthly: 'Mensualmente',
        Yearly: 'Anualmente',
    },
    nlNL: {
        'Are you sure you want to delete this event?': 'Weet u zeker dat u dit evenement wilt verwijderen?',
        Cancel: 'Annuleren',
        Delete: 'Verwijderen',
        'You are editing the first in a series of recurring events.': 'U bewerkt de eerste in een reeks terugkerende evenementen.',
        'This event is in a hidden calendar.': 'Dit evenement bevindt zich in een verborgen agenda.',
        Title: 'Titel',
        'Start date': 'Startdatum',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Einddatum',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Hele dag evenement',
        Frequency: 'Frequentie',
        Until: 'Tot',
        Description: 'Beschrijving',
        People: 'Personen',
        Calendar: 'Agenda',
        Resource: 'Bron',
        Save: 'Opslaan',
        Once: 'Eenmalig',
        Daily: 'Dagelijks',
        Weekly: 'Wekelijks',
        Monthly: 'Maandelijks',
        Yearly: 'Jaarlijks',
    },
    skSK: {
        'Are you sure you want to delete this event?': 'Naozaj chcete odstrániť túto udalosť?',
        Cancel: 'Zrušiť',
        Delete: 'Odstrániť',
        'You are editing the first in a series of recurring events.': 'Upravujete prvý v rade opakujúcich sa udalostí.',
        'This event is in a hidden calendar.': 'Táto udalosť je v skrytom kalendári.',
        Title: 'Názov',
        'Start date': 'Dátum začiatku',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Dátum ukončenia',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Celodenná udalosť',
        Frequency: 'Frekvencia',
        Until: 'Do',
        Description: 'Popis',
        People: 'Ľudia',
        Calendar: 'Kalendár',
        Resource: 'Zdroj',
        Save: 'Uložiť',
        Once: 'Raz',
        Daily: 'Dennodenne',
        Weekly: 'Týždenne',
        Monthly: 'Mesačne',
        Yearly: 'Ročne',
    },
    trTR: {
        'Are you sure you want to delete this event?': 'Bu etkinliği silmek istediğinizden emin misiniz?',
        Cancel: 'İptal',
        Delete: 'Sil',
        'You are editing the first in a series of recurring events.': 'Tekrarlanan etkinlikler serisindeki ilk etkinliği düzenliyorsunuz.',
        'This event is in a hidden calendar.': 'Bu etkinlik gizli bir takvimde.',
        Title: 'Başlık',
        'Start date': 'Başlangıç tarihi',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Bitiş tarihi',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Tüm gün etkinliği',
        Frequency: 'Sıklık',
        Until: 'Kadar',
        Description: 'Açıklama',
        People: 'Kişiler',
        Calendar: 'Takvim',
        Resource: 'Kaynak',
        Save: 'Kaydet',
        Once: 'Bir kez',
        Daily: 'Günlük',
        Weekly: 'Haftalık',
        Monthly: 'Aylık',
        Yearly: 'Yıllık',
    },
    idID: {
        'Are you sure you want to delete this event?': 'Apakah Anda yakin ingin menghapus acara ini?',
        Cancel: 'Batal',
        Delete: 'Hapus',
        'You are editing the first in a series of recurring events.': 'Anda sedang mengedit yang pertama dalam serangkaian acara berulang.',
        'This event is in a hidden calendar.': 'Acara ini berada dalam kalender tersembunyi.',
        Title: 'Judul',
        'Start date': 'Tanggal mulai',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Tanggal berakhir',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Acara sepanjang hari',
        Frequency: 'Frekuensi',
        Until: 'Sampai',
        Description: 'Deskripsi',
        People: 'Orang',
        Calendar: 'Kalender',
        Resource: 'Sumber',
        Save: 'Simpan',
        Once: 'Sekali',
        Daily: 'Harian',
        Weekly: 'Mingguan',
        Monthly: 'Bulanan',
        Yearly: 'Tahunan',
    },
    csCZ: {
        'Are you sure you want to delete this event?': 'Opravdu chcete toto událost smazat?',
        Cancel: 'Zrušit',
        Delete: 'Smazat',
        'You are editing the first in a series of recurring events.': 'Upravujete první v sérii opakujících se událostí.',
        'This event is in a hidden calendar.': 'Tato událost je ve skrytém kalendáři.',
        Title: 'Název',
        'Start date': 'Datum začátku',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Datum konce',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Celodenní událost',
        Frequency: 'Frekvence',
        Until: 'Do',
        Description: 'Popis',
        People: 'Lidé',
        Calendar: 'Kalendář',
        Resource: 'Zdroj',
        Save: 'Uložit',
        Once: 'Jednou',
        Daily: 'Denně',
        Weekly: 'Týdně',
        Monthly: 'Měsíčně',
        Yearly: 'Ročně',
    },
    etEE: {
        'Are you sure you want to delete this event?': 'Kas olete kindel, et soovite selle sündmuse kustutada?',
        Cancel: 'Tühista',
        Delete: 'Kustuta',
        'You are editing the first in a series of recurring events.': 'Muudate korduvate sündmuste seerias esimest.',
        'This event is in a hidden calendar.': 'See sündmus on peidetud kalendris.',
        Title: 'Pealkiri',
        'Start date': 'Alguskuupäev',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Lõppkuupäev',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Terve päeva sündmus',
        Frequency: 'Sagedus',
        Until: 'Kuni',
        Description: 'Kirjeldus',
        People: 'Inimesed',
        Calendar: 'Kalender',
        Resource: 'Ressurss',
        Save: 'Salvesta',
        Once: 'Üks kord',
        Daily: 'Iga päev',
        Weekly: 'Iga nädal',
        Monthly: 'Iga kuu',
        Yearly: 'Iga aasta',
    },
    ukUA: {
        'Are you sure you want to delete this event?': 'Ви впевнені, що хочете видалити цю подію?',
        Cancel: 'Скасувати',
        Delete: 'Видалити',
        'You are editing the first in a series of recurring events.': 'Ви редагуєте перший в серії повторюваних подій.',
        'This event is in a hidden calendar.': 'Ця подія знаходиться в прихованому календарі.',
        Title: 'Назва',
        'Start date': 'Дата початку',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Дата закінчення',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Подія на весь день',
        Frequency: 'Частота',
        Until: 'До',
        Description: 'Опис',
        People: 'Учасники',
        Calendar: 'Календар',
        Resource: 'Ресурс',
        Save: 'Зберегти',
        Once: 'Одноразово',
        Daily: 'Щоденно',
        Weekly: 'Щотижня',
        Monthly: 'Щомісяця',
        Yearly: 'Щороку',
    },
    caES: {
        'Are you sure you want to delete this event?': 'Segur que voleu eliminar aquest esdeveniment?',
        Cancel: 'Cancel·lar',
        Delete: 'Eliminar',
        'You are editing the first in a series of recurring events.': "Esteu editant el primer d'una sèrie d'esdeveniments recurrents.",
        'This event is in a hidden calendar.': 'Aquest esdeveniment està en un calendari ocult.',
        Title: 'Títol',
        'Start date': "Data d'inici",
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Data de finalització',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Esdeveniment de tot el dia',
        Frequency: 'Freqüència',
        Until: 'Fins a',
        Description: 'Descripció',
        People: 'Persones',
        Calendar: 'Calendari',
        Resource: 'Recurs',
        Save: 'Desa',
        Once: 'Un cop',
        Daily: 'Diàriament',
        Weekly: 'Setmanalment',
        Monthly: 'Mensualment',
        Yearly: 'Anualment',
    },
    srRS: {
        'Are you sure you want to delete this event?': 'Да ли сте сигурни да желите да обришете овај догађај?',
        Cancel: 'Откажи',
        Delete: 'Обриши',
        'You are editing the first in a series of recurring events.': 'Уређујете први у серији понављајућих догађаја.',
        'This event is in a hidden calendar.': 'Овај догађај је у скривеном календару.',
        Title: 'Наслов',
        'Start date': 'Датум почетка',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Датум завршетка',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Цео дан',
        Frequency: 'Честота',
        Until: 'До',
        Description: 'Опис',
        People: 'Лица',
        Calendar: 'Календар',
        Resource: 'Ресурс',
        Save: 'Сачувај',
        Once: 'Једном',
        Daily: 'Дневно',
        Weekly: 'Недељно',
        Monthly: 'Месечно',
        Yearly: 'Годишње',
    },
    ltLT: {
        'Are you sure you want to delete this event?': 'Ar tikrai norite ištrinti šį įvykį?',
        Cancel: 'Atšaukti',
        Delete: 'Ištrinti',
        'You are editing the first in a series of recurring events.': 'Redaguojate pirmąjį iš pasikartojančių įvykių serijos.',
        'This event is in a hidden calendar.': 'Šis įvykis yra paslėptame kalendoriuje.',
        Title: 'Pavadinimas',
        'Start date': 'Pradžios data',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Pabaigos data',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Visą dieną trunkantis įvykis',
        Frequency: 'Dažnumas',
        Until: 'Iki',
        Description: 'Aprašymas',
        People: 'Žmonės',
        Calendar: 'Kalendorius',
        Resource: 'Išteklius',
        Save: 'Išsaugoti',
        Once: 'Vieną kartą',
        Daily: 'Kasdien',
        Weekly: 'Kas savaitę',
        Monthly: 'Kas mėnesį',
        Yearly: 'Kasmet',
    },
    hrHR: {
        'Are you sure you want to delete this event?': 'Jeste li sigurni da želite izbrisati ovaj događaj?',
        Cancel: 'Odustani',
        Delete: 'Izbriši',
        'You are editing the first in a series of recurring events.': 'Uređujete prvi u seriji ponavljajućih događaja.',
        'This event is in a hidden calendar.': 'Ovaj događaj je u skrivenom kalendaru.',
        Title: 'Naslov',
        'Start date': 'Datum početka',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Datum završetka',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Cjelodnevni događaj',
        Frequency: 'Frekvencija',
        Until: 'Do',
        Description: 'Opis',
        People: 'Osobe',
        Calendar: 'Kalendar',
        Resource: 'Resurs',
        Save: 'Spremi',
        Once: 'Jednom',
        Daily: 'Dnevno',
        Weekly: 'Tjedno',
        Monthly: 'Mjesečno',
        Yearly: 'Godišnje',
    },
    slSI: {
        'Are you sure you want to delete this event?': 'Ali ste prepričani, da želite izbrisati to dogodek?',
        Cancel: 'Prekliči',
        Delete: 'Izbriši',
        'You are editing the first in a series of recurring events.': 'Urejate prvega v seriji ponavljajočih dogodkov.',
        'This event is in a hidden calendar.': 'Ta dogodek je v skritem koledarju.',
        Title: 'Naslov',
        'Start date': 'Začetni datum',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'Končni datum',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'Celodnevni dogodek',
        Frequency: 'Pogostost',
        Until: 'Do',
        Description: 'Opis',
        People: 'Osebe',
        Calendar: 'Koledar',
        Resource: 'Vir',
        Save: 'Shrani',
        Once: 'Enkrat',
        Daily: 'Dnevno',
        Weekly: 'Tedensko',
        Monthly: 'Mesečno',
        Yearly: 'Letno',
    },
    heIL: {
        'Are you sure you want to delete this event?': 'האם אתה בטוח שברצונך למחוק את האירוע הזה?',
        Cancel: 'ביטול',
        Delete: 'מחק',
        'You are editing the first in a series of recurring events.': 'אתה עורך את הראשון בסדרה של אירועים חוזרים.',
        'This event is in a hidden calendar.': 'האירוע הזה נמצא בלוח שנה מוסתר.',
        Title: 'כותרת',
        'Start date': 'תאריך התחלה',
        'Start time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'End date': 'תאריך סיום',
        'End time': '', // defaults to empty string for stylistic reasons. The layout still makes it clear which field it is.
        'Full-day event': 'אירוע של יום שלם',
        Frequency: 'תדירות',
        Until: 'עד',
        Description: 'תיאור',
        People: 'אנשים',
        Calendar: 'לוח שנה',
        Resource: 'משאב',
        Save: 'שמור',
        Once: 'פעם אחת',
        Daily: 'יומי',
        Weekly: 'שבועי',
        Monthly: 'חודשי',
        Yearly: 'שנתי',
    },
};

exports.createInputField = createInputField;
exports.createInteractiveEventModal = createInteractiveEventModal;
exports.rruleFields = rruleFields;
exports.translations = translations;
